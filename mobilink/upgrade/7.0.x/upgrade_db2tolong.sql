
--
-- Upgrade the MobiLink Server system tables and stored procedures in
-- an IBM DB2 UDB consolidated database.
--


--
-- Fill in your own connection info in the following connect statement.
--
connect to DB2Database~

--
-- Convert short DB2 5.x names to their full length, and add new objects.
-- NOTE: These tables require a tablespace with 8K pages.
--

--
-- Create temporary tables.
--
create table ml_user_temp (
    user_id		    integer	    not null,
    name		    varchar( 128 )  not null,
    hashed_password	    varchar( 32 ) for bit data )
~

create table ml_database_temp (
    rid			    integer	    not null,
    remote_id		    varchar( 128 )  not null,
    description		    varchar( 128 ) )
~

create table ml_subscription_temp (
    rid			    integer	    not null,
    subscription_id	    varchar( 128 )  not null default '<unknown>',
    user_id		    integer	    not null,
    progress		    decimal( 20 )   not null default 0,
    publication_name	    varchar( 128 )  not null default '<unknown>',
    last_upload_time	    timestamp	    not null default '1900-01-01 00:00:00',
    last_download_time	    timestamp	    not null default '1900-01-01 00:00:00' )
~

--
-- Store the old information into the temporary tables.
--
export to ml_userdata.ixf of ixf select user_id, name, hashed_password from ml_user
~
import from ml_userdata.ixf of ixf insert into ml_user_temp
~

insert into ml_database_temp ( rid, remote_id, description )
    select user_id, name, name
	from ml_user
~

insert into ml_subscription_temp ( rid, user_id, progress )
    select user_id, user_id, commit_state
	from ml_user where commit_state <> 0
~

insert into ml_subscription_temp ( rid, user_id, progress )
    select user_id, user_id, progress
	from ml_user where progress <> 0
~

--
-- Drop the old ml_user table.
--
drop table ml_user
~

drop table ml_database
~

--
-- Add new tables for user authentication using LDAP servers
--
create table ml_ldap_server (
    ldsrv_id		integer		not null generated by default as identity
			(start with 1, increment by 1),
    ldsrv_name		varchar( 128 )	not null unique,
    search_url		varchar( 1024 )	not null,
    access_dn		varchar( 1024 )	not null,
    access_dn_pwd	varchar( 256 )	not null,
    auth_url		varchar( 1024 )	not null,
    num_retries		smallint	default 3,
    timeout		integer		default 10,
    start_tls		smallint	default 0,
    primary key ( ldsrv_id ) ) 
~

create table ml_trusted_certificates_file (
    file_name		varchar( 1024 ) not null ) 
~

create table ml_user_auth_policy (
    policy_id			integer		not null generated by default as identity
				(start with 1, increment by 1),
    policy_name			varchar( 128 )	not null unique,
    primary_ldsrv_id		integer		not null,
    secondary_ldsrv_id		integer,
    ldap_auto_failback_period	integer		default 900,
    ldap_failover_to_std	smallint	default 1,
    foreign key( primary_ldsrv_id ) references ml_ldap_server( ldsrv_id ),
    foreign key( secondary_ldsrv_id ) references ml_ldap_server( ldsrv_id ),
    primary key( policy_id ) ) 
~

--
-- Restructure the ml_user and ml_database tables.
--

create procedure ml_create_ml_user_database_temp()
    language SQL
begin
    declare v_id_int	integer;
    declare v_id_str	varchar( 32 );
    declare v_sql_str	varchar( 1028 );
    
    if exists ( select user_id from ml_user_temp ) then
	select max( user_id ) + 1 into v_id_int from ml_user_temp;
    else
	set v_id_int = 1;
    end if;
    set v_id_str = char( v_id_int );
    
    set v_sql_str = 'create table ml_user ( ' ||
	    'user_id         integer not null generated by default as identity ' ||
	    '                (start with ' || v_id_str || ', increment by 1), ' ||
	    'name            varchar( 128 ) not null unique, ' ||
	    'hashed_password varchar( 32 ) for bit data, ' ||
	    'policy_id       integer, ' ||
	    'user_dn         varchar( 1024 ), ' ||
	    'foreign key( policy_id ) references ml_user_auth_policy( policy_id ), ' ||
	    'primary key (user_id) ) ';
    execute immediate v_sql_str;
    
    if exists ( select rid from ml_database_temp ) then
	select max( rid ) + 1 into v_id_int from ml_database_temp;
    else
	set v_id_int = 1;
    end if;
    set v_id_str = char( v_id_int );
    
    set v_sql_str = 'create table ml_database ( ' ||
	    'rid         integer not null generated by default as identity ' ||
	    '            (start with ' || v_id_str || ', increment by 1), ' ||
	    'remote_id   varchar( 128 ) not null unique, ' ||
	    'script_ldt  timestamp	not null default ''1900-01-01 00:00:00'',' ||
	    'seq_id	 varchar(16)	for bit data, ' ||
	    'seq_uploaded integer	not null default 0, ' ||
	    'sync_key	 varchar( 40 ), ' ||
	    'description varchar( 128 ), ' ||
	    'primary key (rid) ) ';
    execute immediate v_sql_str;
end
~

call ml_create_ml_user_database_temp()
~

drop procedure ml_create_ml_user_database_temp()
~

insert into ml_user ( user_id, name, hashed_password )
    select user_id, name, hashed_password
	from ml_user_temp
~

insert into ml_database ( rid, remote_id, description )
    select rid, remote_id, description
	from ml_database_temp
~
    
--
-- Restructure the ml_subscription table.
--
create table ml_subscription (
    rid			    integer	    not null references ml_database ( rid ),
    subscription_id	    varchar( 128 )  not null default '<unknown>',
    user_id		    integer	    not null references ml_user ( user_id ),
    progress		    decimal( 20 )   not null default 0,
    publication_name	    varchar( 128 )  not null default '<unknown>',
    last_upload_time	    timestamp	    not null default '1900-01-01 00:00:00',
    last_download_time	    timestamp	    not null default '1900-01-01 00:00:00',
    primary key (rid,subscription_id) )
~

insert into ml_subscription ( rid, user_id, subscription_id,
			      progress, publication_name,
			      last_upload_time, last_download_time )
    select rid, user_id, subscription_id, progress,
	   publication_name, last_upload_time, last_download_time
    from ml_subscription_temp
~

drop table ml_subscription_temp
~

drop table ml_database_temp
~

drop table ml_user_temp
~

--
-- Add the new script_language column to the ml_script table.
--
alter table ml_script add
    script_language	varchar( 128 )	not null default 'sql'
~

alter table ml_script add
    checksum		varchar( 64 )
~

create table ml_column (
    version_id	integer		not null,
    table_id	integer		not null,
    idx		integer		not null,
    name	varchar( 128 )	not null,
    type	varchar( 128 ),
    primary key( idx, version_id, table_id ),
    unique( version_id, table_id, name ) )
~

create view ml_columns as
select ml_script_version.name version,
       ml_table.name table_name,
       ml_column.name column_name,
       ml_column.type data_type,
       ml_column.idx column_order
from ml_script_version,
     ml_table,
     ml_column
where ml_column.version_id = ml_script_version.version_id
and ml_column.table_id = ml_table.table_id
~

--
-- Add the ml_primary_server table
--
create table ml_primary_server (
    server_id		integer		not null generated by default as identity
				(start with 1, increment by 1),
    name		varchar( 128 )	not null unique,
    connection_info	varchar( 2048 )	not null,
    instance_key	varchar( 32 ) for bit data not null,
    start_time		timestamp	not null default current timestamp,
    primary key( server_id ) )
~

--
-- Add SQL Batch tables and related procedures
--
create table ml_passthrough_script (
    script_id			integer	not null generated by default as identity
				(start with 1, increment by 1),
    script_name			varchar( 128 ) not null unique,
    flags			varchar( 256 ),
    affected_pubs		clob( 10m ),
    script			clob( 10m ) not null,
    description 		varchar( 2000 ),
    primary key( script_id ) )
~

create table ml_passthrough (
    remote_id			varchar( 128 ) not null,
    run_order			integer not null,
    script_id			integer	not null,
    last_modified 		timestamp not null default current timestamp,
    primary key( remote_id, run_order ),
    foreign key( remote_id ) references ml_database( remote_id ),
    foreign key( script_id ) references ml_passthrough_script( script_id ) )
~

create table ml_passthrough_status (
    status_id			integer not null generated by default as identity
				(start with 1, increment by 1),
    remote_id			varchar( 128 ) not null,
    run_order			integer not null,
    script_id			integer	not null,
    script_status		char( 1 ) not null,
    error_code			integer,
    error_text			clob( 10m ),
    remote_run_time		timestamp not null,
    primary key( status_id ),
    unique( remote_id, run_order, remote_run_time ),
    foreign key( remote_id ) references ml_database( remote_id ) )
~

create table ml_passthrough_repair (
    failed_script_id		integer	not null,
    error_code			integer	not null,
    new_script_id		integer,
    action			char( 1 ) not null,
    primary key( failed_script_id, error_code ),
    foreign key( failed_script_id ) references ml_passthrough_script( script_id ) )
~

create trigger ml_passthrough_tri no cascade before update on ml_passthrough
    referencing new as n
    for each row
    mode db2sql
    begin atomic
	set n.last_modified = current timestamp;
    end
~
    
create procedure ml_add_passthrough_script(
				in p_script_name	varchar( 128 ),
				in p_flags		varchar( 256 ),
				in p_affected_pubs	varchar( 4000 ),
				in p_script		varchar( 4000 ),
				in p_description	varchar( 2000 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare SQLSTATE char(5);
      declare v_count  integer;
      declare v_substr varchar( 256 );
      declare v_str    varchar( 256 );
      declare v_start  integer;
      declare v_end    integer;
      declare v_error  integer;
      declare v_done   integer;
      declare v_message varchar( 70 );
      
      IF p_script_name is not null AND p_script is not null THEN
        set v_error = 0;
	IF p_flags is not null THEN
	  set v_str = p_flags;
	  set v_start = 1;
	  set v_done = 0;
	  flag_loop: LOOP
	    set v_end = locate( ';', v_str );
	    IF v_end = 0 and length( v_str) <> 0 THEN
	      set v_end = length( v_str ) + 1;
	      set v_done = 1;
	    ELSEIF v_end = 1 and length( v_str ) = v_end THEN
	      LEAVE flag_loop; 
	    ELSEIF v_end = 0 and length( v_str ) = 0 THEN
	      LEAVE flag_loop;   
	    END IF;
	    set v_substr = substr( v_str, v_start, v_end - v_start );
	    IF v_substr is not null and length( v_substr ) <> 0 THEN
	      IF v_substr not in ( 'manual', 
	          'exclusive', 'schema_diff' ) THEN
		set v_message = 'Invalid flags: "' CONCAT
		    v_substr CONCAT '".' ; 	   
	        SIGNAL SQLSTATE '75002'
		    set MESSAGE_TEXT = v_message ; 	   
		set v_error = 1;    
		LEAVE flag_loop;
	      END IF;
	    END IF;
	    IF v_done = 1 THEN
	      LEAVE flag_loop;
	    END IF;
	    IF  length( v_str ) < (v_end+1) THEN
	      LEAVE flag_loop;
	    ELSE    
	      set v_str = substr( v_str, v_end + 1, 
	          length( v_str ) - v_end );
            END IF;		 
	  END LOOP;
	END IF;
	IF v_error = 0 THEN	         	
          select count(*) into v_count from ml_passthrough_script
	      where script_name = p_script_name;
	  IF v_count = 0 THEN
	    insert into ml_passthrough_script( script_name, flags, 
	        affected_pubs, script, description )
	        values( p_script_name, p_flags, p_affected_pubs,
	        p_script, p_description );
	  ELSE
	    set v_message = 'Script name "' CONCAT
		  p_script_name CONCAT '" already  exists in ' CONCAT
		  'ml_passthrough_script. Please choose ' CONCAT
		  'another script name.';
	  
	    SIGNAL SQLSTATE '75002'
	        set MESSAGE_TEXT = v_message ; 	   
	  END IF;
	END IF;  
      ELSE 
        set v_message = 'Neither passthrough script' CONCAT
	    ' name nor script content can be null.' ;
        SIGNAL SQLSTATE '75002' 
	    set MESSAGE_TEXT = v_message ; 	   
      END IF;	          
    END
~

create procedure ml_delete_passthrough_script( in p_script_name	varchar( 128 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare v_script_id  integer;
      declare v_cnt1 integer;
      declare v_cnt2 integer;
      
      select script_id into v_script_id from ml_passthrough_script
          where script_name = p_script_name;
      IF v_script_id is not null THEN	  
        select count(*) into v_cnt1 from ml_passthrough
	    where script_id = v_script_id;
	select count(*) into v_cnt2 from ml_passthrough_repair
	    where failed_script_id = v_script_id or
	          new_script_id = v_script_id;
	IF v_cnt1 = 0 and v_cnt2 = 0 THEN
	  delete from ml_passthrough_script
	      where script_id = v_script_id;	      
	END IF;
      END IF;
    END
~

create procedure ml_add_passthrough(
       in p_remote_id           varchar( 128 ),
       in p_script_name         varchar( 128 ),
       in p_run_order           integer )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare SQLSTATE char(5);
      declare SQLCODE integer default 0;
      declare v_rid   varchar( 128 );
      declare v_name  varchar( 128 );
      declare v_order integer;
      declare v_count integer;
      declare v_script_id integer;
      declare v_message varchar( 70 );
      declare crsr cursor for select remote_id 
                from ml_database for read only;
      
      select script_id into v_script_id from ml_passthrough_script
           where script_name = p_script_name;
      
      IF v_script_id is not null THEN
        IF p_run_order is not null and p_run_order < 0 THEN
	  set v_message = 'A negative value for ' CONCAT
	    'run_order is not allowed';
	  SIGNAL SQLSTATE '75002'
	        set MESSAGE_TEXT = v_message ; 	   
	ELSE
          IF p_remote_id is null THEN
	    IF p_run_order is null THEN
	      select coalesce( max( run_order ) + 10, 10 ) 
	        into v_order from ml_passthrough;
	    ELSE
	      set v_order = p_run_order;
	    END IF;
	    open crsr;
	    fetch_loop: LOOP
	      fetch crsr into v_rid;
	      IF SQLCODE = 100 THEN 
	        LEAVE fetch_loop;
	      END IF;
	      insert into ml_passthrough( remote_id, run_order, script_id )
	        values( v_rid, v_order, v_script_id );
            END LOOP;
	    close crsr;		
	  ELSE
	    IF p_run_order is null THEN
	      select coalesce( max( run_order ) + 10, 10 ) 
	          into v_order from ml_passthrough 
		  where remote_id = p_remote_id;
	      insert into ml_passthrough( remote_id, run_order, script_id)
	          values( p_remote_id, v_order, v_script_id);
            ELSE		  
	      select count(*) into v_count from ml_passthrough
	        where remote_id = p_remote_id and
		run_order = p_run_order;  
	      IF v_count > 0 THEN
	        update ml_passthrough set script_id = v_script_id,
		    last_modified = current timestamp
		    where remote_id = p_remote_id and 
		          run_order = p_run_order;
	      ELSE
	        insert into ml_passthrough( remote_id, run_order, script_id)
	          values( p_remote_id, p_run_order, v_script_id);
	      END IF;
	    END IF;
	  END IF;
	END IF;  
      ELSE
        IF p_script_name is not null THEN
	  set v_name = p_script_name;
	ELSE
	  set v_name = 'NULL';
	END IF;
        set v_message = 'Passthrough scrip name: "' CONCAT
	    v_name CONCAT '" does not exist in the ' CONCAT
	    'ml_passthrough_script table.' ;
	SIGNAL SQLSTATE '75002'
	    set MESSAGE_TEXT = v_message;
      END IF;
    END  	    
~

create procedure ml_delete_passthrough(
       in p_remote_id           varchar( 128 ),
       in p_script_name         varchar( 128 ),
       in p_run_order           integer )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      IF p_remote_id is null THEN
        IF p_run_order is null THEN
          delete from ml_passthrough where script_id in
	    ( select script_id from ml_passthrough_script 
	    where script_name = p_script_name );
	ELSE
          delete from ml_passthrough where run_order = p_run_order and
	    script_id in ( select script_id from ml_passthrough_script 
	    where script_name = p_script_name );
	END IF;      
      ELSE
        IF p_run_order is null THEN
          delete from ml_passthrough where remote_id = p_remote_id
	    and script_id in ( select script_id from ml_passthrough_script
	    where script_name = p_script_name );
	ELSE 
          delete from ml_passthrough where remote_id = p_remote_id
	    and run_order = p_run_order 
	    and script_id in ( select script_id from ml_passthrough_script
	    where script_name = p_script_name );
	END IF;    
      END IF;	    
    END
~

create procedure ml_add_passthrough_repair(
       in p_failed_snm          varchar( 128 ),
       in p_error_code          integer,
       in p_new_script_name     varchar( 128 ),
       in p_action              char( 1 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare SQLSTATE char(5);
      declare v_failed_sid integer;
      declare v_new_script_id integer;
      declare v_count integer;
      declare v_name  varchar( 128 );
      declare v_message varchar( 70 );
      
      select script_id into v_failed_sid from ml_passthrough_script
          where script_name = p_failed_snm;
      IF v_failed_sid is not null THEN 
        IF p_action in ( 'R','S','P','H','r','s','p','h' ) THEN 
	  IF p_action in ( 'R', 'r' ) 
	       and p_new_script_name is null THEN
	    set v_message = 'The new_script_name cannot ' CONCAT
	      'be null for action "' CONCAT p_action CONCAT '".';
	    SIGNAL SQLSTATE '75002'
	      set MESSAGE_TEXT = v_message;
	  ELSEIF p_action in ( 'S', 'P', 'H', 's', 'p', 'h' )  
	         and p_new_script_name is not null THEN        
	    set v_message = 'The new_script_name should ' CONCAT
	      'be null for action "' CONCAT p_action CONCAT '".';
	    SIGNAL SQLSTATE '75002'
	      set MESSAGE_TEXT = v_message;
	  ELSEIF p_new_script_name is not null and 
	      not exists ( select * from ml_passthrough_script 
	            where script_name = p_new_script_name ) THEN    
	    set v_message = 'Invalid new_script_name: "' CONCAT
	      p_new_script_name CONCAT '".';
	    SIGNAL SQLSTATE '75002'
	      set MESSAGE_TEXT = v_message;
	  ELSE
	    select script_id into v_new_script_id from ml_passthrough_script
	        where script_name = p_new_script_name;
	    select count(*) into v_count from ml_passthrough_repair
	        where failed_script_id = v_failed_sid and
		error_code = p_error_code;
	    IF v_count > 0 THEN		
	      update ml_passthrough_repair 
	          set new_script_id = v_new_script_id,
	          action = p_action 
	          where failed_script_id = v_failed_sid and
	            error_code = p_error_code;
            ELSE		    
	      insert into ml_passthrough_repair ( failed_script_id,
	          error_code, new_script_id, action ) values 
		  ( v_failed_sid, p_error_code, 
		  v_new_script_id, p_action );
	    END IF;
	  END IF;  
        ELSE
	  IF p_action is not null THEN
	    set v_name = p_action; 
	  ELSE
	    set v_name = 'NULL';
	  END IF;
	  set v_message = 'Invalid action: "' CONCAT
	      v_name CONCAT '".' ;
	  SIGNAL SQLSTATE '75002'
	      set MESSAGE_TEXT = v_message;
	END IF;
      ELSE
        IF p_failed_snm is not null THEN
	  set v_name = p_failed_snm;
	ELSE
	  set v_name = 'NULL';
	END IF;
        set v_message = 'Invalid failed_script_name: "'
	    CONCAT v_name CONCAT '".' ;    	         
	SIGNAL SQLSTATE '75002'
	    set MESSAGE_TEXT = v_message;
      END IF;		      		              
    END
~

create procedure ml_delete_passthrough_repair(
       in p_failed_snm          varchar( 128 ),
       in p_error_code          integer )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      IF p_error_code is null THEN
        delete from ml_passthrough_repair where failed_script_id =
	    ( select script_id from ml_passthrough_script 
	      where script_name = p_failed_snm );
      ELSE
        delete from ml_passthrough_repair where failed_script_id =
	    ( select script_id from ml_passthrough_script 
	      where script_name = p_failed_snm ) and
	      error_code = p_error_code;
      END IF;   	
    END
~

--
-- Replace the ml_connection_scri table with the ml_connection_script table.
--
create table ml_connection_script ( 
    version_id		integer		not null references ml_script_version ( version_id ), 
    event		varchar( 128 )  not null, 
    script_id		integer		not null references ml_script ( script_id ), 
    primary key (version_id, event) )
~

INSERT INTO ml_connection_script ( version_id, event, script_id )
    SELECT version_id, event, script_id FROM ml_connection_scri
~

drop table ml_connection_scri
~

--
-- Replace the ml_scripts_modifie table with the ml_scripts_modified table.
--
create table ml_scripts_modified ( 
    last_modified	timestamp	primary key not null )
~

delete from ml_scripts_modified
~
insert into ml_scripts_modified ( last_modified ) values ( current timestamp )
~

drop table ml_scripts_modifie
~

drop trigger ml_s_trigger_i
~
drop trigger ml_s_trigger_u
~
drop trigger ml_s_trigger_d
~

drop trigger ml_ts_trigger_i
~
drop trigger ml_ts_trigger_u
~
drop trigger ml_ts_trigger_d
~

drop trigger ml_cs_trigger_i
~
drop trigger ml_cs_trigger_u
~
drop trigger ml_cs_trigger_d
~

create trigger ml_s_trigger_i after insert on ml_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_s_trigger_u after update on ml_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_s_trigger_d after delete on ml_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~

create trigger ml_ts_trigger_i after insert on ml_table_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_ts_trigger_u after update on ml_table_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_ts_trigger_d after delete on ml_table_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~

create trigger ml_cs_trigger_i after insert on ml_connection_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_cs_trigger_u after update on ml_connection_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_cs_trigger_d after delete on ml_connection_script 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~

create trigger ml_cl_trigger_i after insert on ml_column 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_cl_trigger_u after update on ml_column 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~
create trigger ml_cl_trigger_d after delete on ml_column 
    for each row 
    mode db2sql 
begin atomic 
    update ml_scripts_modified set last_modified = current timestamp; 
end
~

--
-- Replace the ml_add_connection_ stored procedure, and add some new ones.
--
drop procedure ml_add_connection_
~

create procedure ml_add_lang_conn_script_chk(
				    in p_version	 varchar( 128 ),
				    in p_event		 varchar( 128 ),
				    in p_script_language varchar( 128 ),
				    in p_script		 varchar( 4000 ),
				    in p_checksum	 varchar( 64 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare v_version_id integer default null;
      declare v_script_id integer;
      declare v_upd_script_id integer;
       
      select version_id into v_version_id from ml_script_version 
               where name = p_version;
      if p_script is  not NULL then
        if v_version_id is NULL then 
	  select max( version_id ) + 1 into v_version_id 
	      from ml_script_version;
	  if v_version_id is NULL then
	     set v_version_id = 1;
	  end if;
	  insert into ml_script_version ( version_id, name ) 
	     values( v_version_id, p_version );
	end if;
	                 
        select max( script_id ) + 1 into v_script_id from ml_script;	
	if v_script_id is NULL then 
	  set v_script_id = 1;
	end if;
	insert into ml_script( script_id, script_language, 
	  script, checksum )  values
	  ( v_script_id, p_script_language, p_script, p_checksum );
	select script_id into v_upd_script_id from ml_connection_script
	  where version_id = v_version_id and event = p_event;
	    
	if v_upd_script_id is NULL then
	  insert into ml_connection_script ( version_id, event, script_id )
	    values ( v_version_id, p_event, v_script_id );
	else 
	  update ml_connection_script set script_id = v_script_id
	    where version_id = v_version_id and event = p_event;
	end if;
	                
      else
        if v_version_id is not NULL then
	  delete from ml_connection_script where version_id = v_version_id
	     and event = p_event;
	end if;      
      end if;
     END
~

create procedure ml_add_lang_connection_script( 
				     in p_version	  varchar( 128 ),  
				     in p_event		  varchar( 128 ), 
				     in p_script_language varchar( 128 ), 
				     in p_script	  varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_CONN_SCRIPT_CHK( p_version, p_event, 
          p_script_language, p_script, null );
    END
~

create procedure ml_add_connection_script( in p_version varchar( 128 ),  
					   in p_event   varchar( 128 ), 
					   in p_script  varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_CONNECTION_SCRIPT( p_version, p_event, 'sql', p_script );
    END
~

create procedure ml_add_java_connection_script( in p_version varchar( 128 ),  
						in p_event   varchar( 128 ), 
						in p_script  varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_CONNECTION_SCRIPT( p_version, p_event, 'java', p_script );
    END
~

create procedure ml_add_dnet_connection_script( in p_version varchar( 128 ),  
						in p_event   varchar( 128 ), 
						in p_script  varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_CONNECTION_SCRIPT( p_version, p_event, 'dnet', p_script );
    END
~

--
-- Replace the ml_add_table_scrip stored procedure, and add some new ones.
--
drop procedure ml_add_table_scrip
~

create procedure ml_add_lang_table_script_chk(
				    in p_version         varchar( 128 ),
				    in p_table           varchar( 128 ),
				    in p_event           varchar( 128 ),
				    in p_script_language varchar( 128 ),
				    in p_script	         varchar( 4000 ),
				    in p_checksum	 varchar( 64 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare v_version_id integer default null;
      declare v_table_id integer default null;
      declare v_script_id integer;
      declare v_upd_script_id integer;
       
      select version_id into v_version_id from ml_script_version 
               where name = p_version;
      select table_id into v_table_id from ml_table
               where name = p_table;	       			      
      if p_script is  not NULL then
        if v_version_id is NULL then 
	  select max( version_id ) + 1 into v_version_id 
	     from ml_script_version;
	  if v_version_id is NULL then
	     set v_version_id = 1;
	  end if;
	  insert into ml_script_version ( version_id, name ) 
	     values( v_version_id, p_version );
	end if;
	if v_table_id is NULL then 
	  select max( table_id ) + 1 into v_table_id from ml_table;
	  if v_table_id is NULL then
	     set v_table_id = 1;
	  end if;
	  insert into ml_table ( table_id, name ) 
	     values ( v_table_id, p_table );
	end if;
	                 
        select max( script_id ) + 1 into v_script_id from ml_script;	
	if v_script_id is NULL then 
	  set v_script_id = 1;
	end if;
	insert into ml_script( script_id, script_language, 
	  script, checksum ) 
	  values( v_script_id, p_script_language, 
	  p_script, p_checksum );
	select script_id into v_upd_script_id from ml_table_script
	  where version_id = v_version_id and table_id = v_table_id
	    and event = p_event;
	    
	if v_upd_script_id is NULL then
	  insert into ml_table_script ( version_id, table_id, 
	    event, script_id )
	    values ( v_version_id, v_table_id, 
	    p_event, v_script_id );
	else 
	  update ml_table_script set script_id = v_script_id
	    where version_id = v_version_id and table_id = v_table_id
	      and event = p_event;
	end if;
	                
      else
        if v_version_id is not NULL and v_table_id is not NULL then
	  delete from ml_table_script where version_id = v_version_id
	     and table_id = v_table_id and event = p_event;
	end if;      
      end if;
    END
~

create procedure ml_add_lang_table_script( 
				     in p_version	  varchar( 128 ),  
				     in p_table		  varchar( 128 ), 
				     in p_event		  varchar( 128 ), 
				     in p_script_language varchar( 128 ), 
				     in p_script	  varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_TABLE_SCRIPT_CHK( p_version, p_table, p_event, 
          p_script_language, p_script, null );
    END
~

create procedure ml_add_table_script( in p_version    varchar( 128 ),  
				      in p_table      varchar( 128 ), 
				      in p_event      varchar( 128 ), 
				      in p_script     varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_TABLE_SCRIPT( p_version, p_table, p_event, 
          'sql', p_script );
    END
~

create procedure ml_add_java_table_script( in p_version	varchar( 128 ),  
					   in p_table	varchar( 128 ), 
					   in p_event  	varchar( 128 ), 
					   in p_script	varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_TABLE_SCRIPT( p_version, p_table, p_event, 
          'java', p_script );
    END
~

create procedure ml_add_dnet_table_script( in p_version	varchar( 128 ),  
					   in p_table	varchar( 128 ), 
					   in p_event  	varchar( 128 ), 
					   in p_script	varchar( 4000 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ML_ADD_LANG_TABLE_SCRIPT( p_version, p_table, p_event, 
          'dnet', p_script );
    END
~


create view ml_connection_scripts as
select ml_script_version.name version,
       ml_connection_script.event,
       ml_script.script_language,
       ml_script.script
from ml_connection_script,
     ml_script_version,
     ml_script
where ml_connection_script.version_id = ml_script_version.version_id
and ml_connection_script.script_id = ml_script.script_id
~

create view ml_table_scripts as
select ml_script_version.name version,
       ml_table_script.event,
       ml_table.name table_name,
       ml_script.script_language,
       ml_script.script
from ml_table_script,
     ml_script_version,
     ml_script,
     ml_table
where ml_table_script.version_id = ml_script_version.version_id
and ml_table_script.script_id = ml_script.script_id
and ml_table_script.table_id = ml_table.table_id
~

create table ml_property (
    component_name		varchar( 128 )	not null,
    property_set_name		varchar( 128 )	not null,
    property_name		varchar( 128 )	not null,
    property_value		clob( 30K )	not null,
    primary key (component_name, property_set_name, property_name ) )
~

create procedure ml_add_property( in comp_name	    varchar( 128 ),
				  in prop_set_name  varchar( 128 ),
				  in prop_name	    varchar( 128 ),
				  in prop_value	    varchar( 4000 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare p_name   varchar( 128 ) default null;
      
      IF prop_value is null THEN
        delete from ml_property 
	         where  component_name = comp_name
		 and    property_set_name = prop_set_name
		 and	property_name = prop_name;
      ELSE
        select property_name into p_name from ml_property
	         where  component_name = comp_name
		 and    property_set_name = prop_set_name
		 and    property_name = prop_name;  
	IF p_name is null THEN
	   insert into ml_property
	       ( component_name, property_set_name, 
	       property_name, property_value ) 
	       values ( comp_name, prop_set_name, 
	       prop_name, prop_value );
	ELSE
	   update ml_property set property_value = prop_value
	       where component_name = comp_name
	       and property_set_name = prop_set_name
	       and property_name = prop_name;
        END IF;			             
      END IF;	
      	       	
    END
~

create table ml_device (
    device_name		varchar(255)	not null,
    listener_version	varchar(128)	not null,
    listener_protocol	integer		not null,
    info		varchar(255)	not null,
    ignore_tracking	char(1)		not null,
    source		varchar(255)	not null,
    primary key ( device_name ) )
~

create table ml_device_address (
    device_name		varchar(255)	not null references ml_device ( device_name ),
    medium		varchar(255)	not null,
    address		varchar(255)	not null,
    active		char(1)		not null,
    last_modified	timestamp	not null default current timestamp,
    ignore_tracking	char(1)		not null,
    source		varchar(255)	not null,
    primary key ( device_name, medium ) )
~

create table ml_listening (
    name		varchar(128)	not null,
    device_name		varchar(255)	not null references ml_device ( device_name ),
    listening		char(1)		not null,
    ignore_tracking	char(1)		not null,
    source		varchar(255)	not null
    ,
    primary key ( name ) )
~

create table ml_sis_sync_state (
    remote_id		varchar( 128 )	not null,
    subscription_id	varchar( 128 )	not null,
    publication_name	varchar( 128 )	not null,
    user_name		varchar( 128 )	not null,
    last_upload		timestamp not null,
    last_download	timestamp not null,
    primary key ( remote_id, subscription_id ) )
~

create procedure ml_set_device( in p_device		varchar( 255 ),
				in p_listener_version	varchar(128),
				in p_listen_protocol    integer,
				in p_info		varchar(255),
				in p_ignore_tracking	char(1),
				in p_source		varchar(255) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare dname varchar( 255 ) default null;
      
      select device_name into dname from ml_device 
          where device_name = p_device;
						
      IF dname is null THEN
        insert into ml_device( device_name, listener_version, 
	       listener_protocol, info, ignore_tracking, source ) 
               values ( p_device, p_listener_version, 
	       p_listen_protocol, p_info, 
	       p_ignore_tracking, p_source );
      ELSE
        IF p_source = 'tracking' THEN
	  update ml_device 
	         set listener_version = p_listener_version,
		     listener_protocol = p_listen_protocol,
		     info = p_info,
		     ignore_tracking = p_ignore_tracking,
		     source = p_source
		 where device_name = p_device 
		 and ignore_tracking = 'n';
        ELSE
	  update ml_device
	         set listener_version = p_listener_version,
		     listener_protocol = p_listen_protocol,
		     info = p_info,
		     ignore_tracking = p_ignore_tracking,
		     source = p_source
		 where device_name = p_device ;
        END IF;		 
      END IF;
    END
~

create procedure ml_set_device_nt( in p_device		 varchar( 255 ),
				   in p_listener_version varchar(128),
				   in p_listen_protocol  integer,
				   in p_info		 varchar(255) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
        CALL ML_SET_DEVICE( p_device, p_listener_version, 
	    p_listen_protocol, p_info, 'n', 'tracking' );
    END
~

create procedure ml_set_device_address( in p_device		varchar(255),
					in p_medium		varchar(255),
					in p_address		varchar(255),
					in p_active		char(1),
					in p_ignore_tracking	char(1),
					in p_source		varchar(255) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare dname varchar( 255 ) default null;
      
      select device_name into dname from ml_device_address
               where device_name = p_device and medium = p_medium;
						
      IF dname is null THEN
        insert into ml_device_address( device_name, medium, 
	       address, active, ignore_tracking, source ) 
               values ( p_device, p_medium, p_address, p_active, 
	       p_ignore_tracking, p_source );
      ELSE
        IF p_source = 'tracking' THEN
	  update ml_device_address
	         set address = p_address,
		     active = p_active,
		     ignore_tracking = p_ignore_tracking,
		     source = p_source
		 where device_name = p_device 
		 and medium = p_medium
		 and ignore_tracking = 'n';
        ELSE
	  update ml_device_address
	         set address = p_address,
		     active = p_active,
		     ignore_tracking = p_ignore_tracking,
		     source = p_source
		 where device_name = p_device 
		 and medium = p_medium;
        END IF;		 
      END IF;
    END
~

create procedure ml_set_device_address_nt( in p_device		varchar(255),
					   in p_medium		varchar(255),
					   in p_address		varchar(255),
					   in p_active		char(1) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
        CALL ML_SET_DEVICE_ADDRESS( p_device, p_medium, 
	    p_address, p_active, 'n', 'tracking' );
    END
~


create procedure ml_set_listening( in p_name		varchar( 128 ),
				   in p_device		varchar( 255 ),
				   in p_listening	char(1),
				   in p_ignore_tracking	char(1),
				   in p_source		varchar(255) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare dname varchar( 255 ) default null;
      
      select device_name into dname from ml_listening 
          where name = p_name;
						
      IF dname is null THEN
        insert into ml_listening( name, device_name, 
	       listening, ignore_tracking, source ) 
               values ( p_name, p_device, p_listening, 
	       p_ignore_tracking, p_source );
      ELSE
        IF p_source = 'tracking' THEN
	  update ml_listening
	         set device_name = p_device,
		     listening = p_listening,
		     ignore_tracking = p_ignore_tracking,
		     source = p_source
		 where name = p_name 
		 and ignore_tracking = 'n';
        ELSE
	  update ml_listening
	         set device_name = p_device,
		     listening = p_listening,
		     ignore_tracking = p_ignore_tracking,
		     source = p_source
		 where name = p_name; 
        END IF;		 
      END IF;
    END
~

create procedure ml_set_listening_nt( in p_name	 	 varchar( 128 ),
				      in p_device	 varchar( 255 ),
				      in p_listening	 char(1) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
        CALL ML_SET_LISTENING( p_name, p_device, p_listening, 
	    'n', 'tracking' );
    END
~

create procedure ml_set_sis_sync_state( in p_remote_id	    varchar( 128 ),
				     in p_subscription_id   varchar( 128 ),
				     in p_publication_name  varchar( 128 ),
				     in p_user_name	    varchar( 128 ),
				     in p_last_upload	    timestamp,
				     in p_last_download	    timestamp )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN    
      declare rid varchar( 128 ) default null;
      declare sid varchar( 128 );
      declare lut timestamp;
      
      IF p_subscription_id is NULL THEN
        set sid = 's:' CONCAT p_publication_name;
      ELSE
        set sid = p_subscription_id;
      END IF;
      
      IF p_last_upload is NULL THEN
        select last_upload into lut from ml_sis_sync_state
	      where remote_id = p_remote_id
	      and subscription_id = sid;
	IF lut is NULL THEN
	  set lut = '1900-01-01-00.00.00';
	END IF;
      END IF;	        		
      
      select remote_id into rid from ml_sis_sync_state 
              where remote_id = p_remote_id
	      and subscription_id = p_subscription_id;
						
      IF rid is null THEN
        insert into ml_sis_sync_state( remote_id, subscription_id, 
	   publication_name, user_name, last_upload, last_download )
           values ( p_remote_id, sid, 
	   p_publication_name, p_user_name, lut, 
	   p_last_download );
      ELSE
	update ml_sis_sync_state
	         set publication_name = p_publication_name,
		     user_name = p_user_name,
		     last_upload = lut,
		     last_download = p_last_download
		 where remote_id = p_remote_id 
		 and subscription_id = sid;
      END IF;
    END
~

create procedure ml_delete_device_address( in p_device	varchar( 255 ),
					   in p_medium	varchar( 255 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      delete from ml_device_address 
             where device_name = p_device and medium = p_medium;
    END
~

create procedure ml_delete_listening( in p_name	varchar( 128 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      delete from ml_listening where name = p_name;
    END
~

create procedure ml_delete_device( in p_device varchar( 255 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      delete from ml_device_address where device_name = p_device;
      delete from ml_listening where device_name = p_device;
      delete from ml_device where device_name = p_device;
    END
~

insert into ml_property values ( 'SIS', 'DeviceTracker(Default-DeviceTracker)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'DeviceTracker(Default-DeviceTracker)', 'smtp_gateway', 'Default-SMTP' )
~
insert into ml_property values ( 'SIS', 'DeviceTracker(Default-DeviceTracker)', 'udp_gateway', 'Default-UDP' )
~
insert into ml_property values ( 'SIS', 'DeviceTracker(Default-DeviceTracker)', 'sync_gateway', 'Default-SYNC' )
~
insert into ml_property values ( 'SIS', 'SMTP(Default-SMTP)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'UDP(Default-UDP)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'SYNC(Default-SYNC)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'BESHTTP(BES_HTTP)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'BESHTTP(BES_HTTP)', 'bes', 'localhost' )
~
insert into ml_property values ( 'SIS', 'BESHTTP(BES_HTTP)', 'port', '8080' )
~
insert into ml_property values ( 'SIS', 'BESHTTP(BES_HTTP)', 'client_port', '4400' )
~
insert into ml_property values ( 'SIS', 'Carrier(Rogers)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'Carrier(Rogers)', 'network_provider_id', 'ROGERS' )
~
insert into ml_property values ( 'SIS', 'Carrier(Rogers)', 'sms_email_user_prefix', '1' )
~
insert into ml_property values ( 'SIS', 'Carrier(Rogers)', 'sms_email_domain', 'pcs.rogers.com' )
~
insert into ml_property values ( 'SIS', 'Carrier(Bell Mobility)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'Carrier(Bell Mobility)', 'network_provider_id', 'BELL' )
~
insert into ml_property values ( 'SIS', 'Carrier(Bell Mobility)', 'sms_email_domain', 'txt.bellmobility.ca' )
~
insert into ml_property values ( 'SIS', 'Carrier(Bell Mobility 1x)', 'enable', 'yes' )
~
insert into ml_property values ( 'SIS', 'Carrier(Bell Mobility 1x)', 'network_provider_id', 'CDMA1x:16420:65535' )
~
insert into ml_property values ( 'SIS', 'Carrier(Bell Mobility 1x)', 'sms_email_domain', 'txt.bellmobility.ca' )
~

commit
~

--
-- Add the new stored procedures
--
create procedure ml_delete_remote_id( in p_remote_id varchar( 128 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare v_rid integer;
    
      select rid into v_rid from ml_database where remote_id = p_remote_id;
      IF v_rid is not null THEN
	delete from ml_subscription where rid = v_rid;
	delete from ml_passthrough_status where remote_id = p_remote_id;
	delete from ml_passthrough where remote_id = p_remote_id;
	delete from ml_database where rid = v_rid;
      END IF;
    END
~

create procedure ml_delete_user_state( in p_user_name varchar( 128 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare SQLCODE integer default 0;
      declare v_uid integer default null;
      declare v_rid integer default null;
      declare v_rid_cnt	integer;
      declare v_remote_id varchar( 128 ) default null;
      declare crsr cursor for select rid from ml_subscription
                         where user_id = v_uid for read only;
      
      IF p_user_name is null THEN
        set v_uid = NULL;
      ELSE 
        select user_id into v_uid from ml_user
	     where name = p_user_name;
      END IF;
      IF v_uid is not NULL THEN 
         open crsr;
	 fetch_loop: LOOP
	   fetch crsr into v_rid;
	   IF SQLCODE = 100 THEN 
	     LEAVE fetch_loop;
	   END IF;
	   delete from ml_subscription
	     where user_id = v_uid and rid = v_rid;
	   select count(*) into v_rid_cnt from ml_subscription
	     where rid = v_rid;
	   IF v_rid_cnt = 0 THEN 
	     delete from ml_database where rid = v_rid;
		select remote_id into v_remote_id from ml_database where rid = v_rid;
		CALL ml_delete_remote_id( v_remote_id );
	   END IF;
	 END LOOP;
	 close crsr;
      END IF;
    END
~

create procedure ml_delete_sync_state( in p_user_name	varchar( 128 ),
				       in p_remote_id	varchar( 128 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare SQLCODE integer default 0;
      declare v_uid integer default null;
      declare v_rid integer default null;
      declare v_rid_cnt integer;
      declare crsr cursor for select rid from ml_subscription
                         where user_id = v_uid for read only;
      
      IF p_user_name is null THEN
        set v_uid = NULL;
      ELSE 
        select user_id into v_uid from ml_user
	     where name = p_user_name;
      END IF;
      IF p_remote_id is null THEN
        set v_rid = NULL;
      ELSE
        select rid into v_rid from ml_database
	     where remote_id = p_remote_id;
      END IF;
      IF p_user_name is not null AND p_remote_id is not null THEN
         delete from ml_passthrough_status where remote_id = p_remote_id;
	 delete from ml_passthrough where remote_id = p_remote_id;
         IF v_uid is not null AND v_rid is not null THEN
	    delete from ml_subscription 
	        where user_id = v_uid and rid = v_rid;
   	 END IF;
	 select count(*) into v_rid_cnt from ml_subscription 
	    where rid = v_rid;
	 IF v_rid_cnt = 0 THEN
	    CALL ml_delete_remote_id( p_remote_id );
	 END IF;
      ELSEIF p_user_name is not null THEN
	 CALL ml_delete_user_state( p_user_name );
      ELSEIF p_remote_id is not null THEN
	 CALL ml_delete_remote_id( p_remote_id );
      END IF;
      	       	
    END
~

create procedure ml_reset_sync_state( in p_user_name	varchar( 128 ),
				      in p_remote_id	varchar( 128 ) ) 
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare v_uid integer default null;
      declare v_rid integer default null;
      
      IF p_user_name is null THEN
        set v_uid = NULL;
      ELSE 
        select user_id into v_uid from ml_user
	     where name = p_user_name;
      END IF;
      IF p_remote_id is null THEN
        set v_rid = NULL;
      ELSE
        select rid into v_rid from ml_database
	     where remote_id = p_remote_id;
      END IF;
      IF p_user_name is not null AND p_remote_id is not null THEN
         IF v_uid is not null AND v_rid is not null THEN
	    update ml_subscription
	       set progress = 0,
	           last_upload_time = '1900-01-01-00.00.00',
		   last_download_time = '1900-01-01-00.00.00'
	       where user_id = v_uid and rid = v_rid;
	 END IF;
      ELSEIF p_user_name is not null THEN
         IF v_uid is not null THEN 
	    update ml_subscription
	       set progress = 0,
	           last_upload_time = '1900-01-01-00.00.00',
		   last_download_time = '1900-01-01-00.00.00'
	       where user_id = v_uid;
	 END IF;
      ELSEIF p_remote_id is not null THEN
         IF v_rid is not null THEN
	    update ml_subscription
	       set progress = 0,
	           last_upload_time = '1900-01-01-00.00.00',
		   last_download_time = '1900-01-01-00.00.00'
	       where rid = v_rid;
	 END IF;
      END IF;	       	   	       	    	       	   
      update ml_database
	 set sync_key = NULL,
	    seq_id = NULL,
	    seq_uploaded = 0,
	    script_ldt = '1900-01-01-00.00.00'
	 where remote_id = p_remote_id;
    END
~

create procedure ml_delete_sync_state_before( in p_ts timestamp )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare SQLCODE integer default 0;
      declare v_rid integer default null;
      declare v_rid_cnt integer;
      declare v_remote_id varchar(128);
      declare crsr cursor for select rid from ml_subscription
                where last_upload_time < p_ts and 
		      last_download_time < p_ts for read only;
      
      IF p_ts is not null THEN
        open crsr;
	fetch_loop: LOOP
	   fetch crsr into v_rid;
	   IF SQLCODE = 100 THEN
	       LEAVE fetch_loop;
	   END IF;
	   delete from ml_subscription 
	          where rid = v_rid and 
		        last_upload_time < p_ts and 
			last_download_time < p_ts;
           select count(*) into v_rid_cnt from ml_subscription
	          where rid = v_rid;
           IF v_rid_cnt = 0 THEN		  			    
	      select remote_id into v_remote_id from ml_database where rid = v_rid;
	      CALL ml_delete_remote_id( v_remote_id );
	   END IF;    
        END LOOP;
	close crsr;
      END IF;	
    END
~

create procedure ml_share_all_scripts( 
    in p_version	varchar( 128 ),
    in p_other_version	varchar( 128 ) )
MODIFIES SQL DATA 
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    declare v_version_id	integer;
    declare v_other_version_id	integer;
    
    select version_id into v_version_id from ml_script_version 
		where name = p_version;
    select version_id into v_other_version_id from ml_script_version 
		where name = p_other_version;

    IF v_version_id is null THEN
      select max( version_id ) + 1 into v_version_id 
	  from ml_script_version;
      IF v_version_id is null THEN
	 set v_version_id = 1;
      END IF;
      insert into ml_script_version( version_id, name )
		  values( v_version_id, p_version );
    END IF;

    insert into ml_table_script( version_id, table_id, event, script_id )
	select v_version_id, table_id, event, script_id from ml_table_script 
	    where version_id = v_other_version_id;
    
    insert into ml_connection_script( version_id, event, script_id )
	select v_version_id, event, script_id from ml_connection_script 
	    where version_id = v_other_version_id;
end
~

create procedure ml_add_missing_dnld_scripts(
    in p_script_version	varchar( 128 ) )
MODIFIES SQL DATA 
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    declare SQLCODE		integer default 0;
    declare v_version_id	integer;
    declare v_table_id		integer;
    declare v_count		integer;
    declare v_count_1		integer;
    declare v_count_2		integer;
    declare v_first		integer;
    declare v_tid		integer;
    declare v_table_name	varchar(128);
    declare crsr cursor for
	    select t.table_id from ml_table_script t, ml_script_version v
		where t.version_id = v.version_id and
		      v.name = p_script_version order by 1;
    
    select version_id into v_version_id from ml_script_version
	where name = p_script_version;
    if v_version_id is not null then
	set v_first = 1;
	open crsr;
	tid: loop
	    fetch crsr into v_table_id;
	    if SQLCODE = 100 then 
		leave tid;
	    end if;
	    if v_first = 1 or v_table_id <> v_tid then
		if not exists (select * from ml_table_script
				where version_id = v_version_id and
				    table_id = v_table_id and
				    event = 'download_cursor') then
		    set v_count_1 = 0;
		else
		    set v_count_1 = 1;
		end if;
		if not exists (select * from ml_table_script
				where version_id = v_version_id and
				    table_id = v_table_id and
				    event = 'download_delete_cursor') then
		    set v_count_2 = 0;
		else
		    set v_count_2 = 1;
		end if;
		if v_count_1 = 0 or v_count_2 = 0 then
		    select name into v_table_name from ml_table where table_id = v_table_id;
		    if v_count_1 = 0 then
			call ml_add_table_script( p_script_version, v_table_name,
			    'download_cursor', '--{ml_ignore}' );
		    end if;
		    if v_count_2 = 0 then
			call ml_add_table_script( p_script_version, v_table_name,
			    'download_delete_cursor', '--{ml_ignore}' );
		    end if;
		end if;
		set v_first = 0;
		set v_tid = v_table_id;
	    end if;
	end loop;
	close crsr;
    end if;
end
~

create procedure ml_add_column(
    in p_version   varchar( 128 ),
    in p_table	   varchar( 128 ),
    in p_column	   varchar( 128 ),
    in p_type	   varchar( 128 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      declare v_version_id integer default null;
      declare v_table_id integer default null;
      declare v_idx integer default null;
      
      select version_id into v_version_id from ml_script_version
                        where name = p_version;
      select table_id into v_table_id from ml_table
                        where name = p_table;
						
      IF p_column is not null THEN
        IF v_version_id is null THEN
	  select max( version_id ) + 1 into v_version_id 
	      from ml_script_version;
	  IF v_version_id is null THEN
	     set v_version_id = 1;
	  END IF;
	  insert into ml_script_version( version_id, name )
	              values( v_version_id, p_version );
        END IF;
	IF v_table_id is null THEN
	  select max( table_id ) + 1 into v_table_id from ml_table;
	  IF v_table_id is null THEN
	     set v_table_id = 1;
	  END IF;
	  insert into ml_table( table_id, name )
	              values( v_table_id, p_table );
	END IF;
	select max( idx) + 1 into v_idx from ml_column
	      where version_id = v_version_id 
	      and table_id = v_table_id;
	IF v_idx is null THEN
	  set v_idx = 1;
	END IF;
	insert into ml_column( version_id, table_id, 
	      idx, name, type ) 
	      values( v_version_id, v_table_id, 
	      v_idx, p_column, p_type );
      ELSE 
        IF v_version_id is not null and v_table_id is not null THEN
	  delete from ml_column where version_id = v_version_id
	         and table_id = v_table_id;
        END IF;		 
      END IF;
    END
~

create procedure ml_lock_rid(
    in		p_rid		integer,
    inout	p_sync_key	varchar(40),
    inout	p_failure	integer )
MODIFIES SQL DATA
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    declare v_error	integer default 0;
    declare continue handler for SQLSTATE '40001' set v_error = 1;
    
    set CURRENT LOCK TIMEOUT 0;
    SELECT sync_key into p_sync_key FROM ml_database
	WHERE rid = p_rid WITH RR USE AND KEEP EXCLUSIVE LOCKS;
    if v_error = 1 then
	set p_failure = 1;
    else
	set p_failure = 0;
    end if;
    set CURRENT LOCK TIMEOUT -1;
end
~

--
-- Add a stored procedure for retrieving locking/blocking information
--
-- Create a stored procedure to get the connections
-- that are currently blocking the connections given
-- by p_appl_ids for more than p_block_time seconds

create procedure ml_create_get_blocked_info_proc()
BEGIN
    declare	v_exist	integer;
    declare	v_sql	varchar(2000);

    select 1 into v_exist from table( sysproc.env_get_inst_info() ) where upper(service_level) like 'DB2 V10.%';
    if v_exist = 1 then
	set v_sql =
	    'create procedure ml_get_blocked_info( in p_appl_ids varchar(2000), in p_block_time integer ) ' ||
	    'MODIFIES SQL DATA  CALLED ON NULL  INPUT LANGUAGE SQL  COMMIT ON RETURN NO  DYNAMIC RESULT SETS 1 ' ||
	    'BEGIN declare v_sel varchar( 2000 ); declare crsr cursor with return to client for dynstmt; ' ||
	    'set v_sel = ''select s1.appl_id,s2.appl_id,l.lock_wait_elapsed_time,1,rtrim(l.tabschema) || ''''.'''' || rtrim(l.tabname)''; ' ||
	    'set v_sel = concat( v_sel, '' from sysibmadm.mon_lockwaits l, table(snapshot_appl_info(NULL,NULL)) s1, table(snapshot_appl_info(NULL,NULL)) s2 '' ); ' ||
	    'set v_sel = concat( v_sel, '' where s1.agent_id = l.req_application_handle and s2.agent_id = l.hld_application_handle and l.lock_wait_elapsed_time > '' ); ' ||
	    'set v_sel = concat( v_sel, p_block_time ); ' ||
	    'set v_sel = concat( v_sel, '' and s1.appl_id in ( '' ); ' ||
	    'set v_sel = concat( v_sel, p_appl_ids ); ' ||
	    'set v_sel = concat( v_sel, '' ) order by 1'' ); ' ||
	    'prepare dynstmt from v_sel; open crsr; END ';
    else
	set v_sql =
	    'create procedure ml_get_blocked_info( in p_appl_ids varchar(2000), in p_block_time integer ) ' ||
	    'MODIFIES SQL DATA  CALLED ON NULL INPUT  LANGUAGE SQL  COMMIT ON RETURN NO  DYNAMIC RESULT SETS 1 ' ||
	    'BEGIN declare v_sel varchar( 1000 ); declare v_ids varchar( 50 ); declare v_ord varchar( 50 ); declare v_sql varchar( 2100 ); ' ||
	    'declare crsr cursor with return to client for dynstmt; ' ||
	    'set v_sel = ''select s.appl_id,l.appl_id_holding_lk,timestampdiff(2,char(l.snapshot_timestamp-l.lock_wait_start_time)),1,concat(concat(rtrim(l.db_name),''''.''''), rtrim(l.tabname)) from sysibmadm.lockwaits l,table(snapshot_appl_info(CAST(NULL AS VARCHAR(128)),-1)) s where l.agent_id=s.agent_id and timestampdiff(2,char(l.snapshot_timestamp-l.lock_wait_start_time)) > ''; ' ||
	    'set v_ids = '' and s.appl_id in ( ''; ' ||
	    'set v_ord = '' ) order by 1''; ' ||
	    'set v_sql = CONCAT( CONCAT( CONCAT( CONCAT( v_sel, CHAR(p_block_time) ), v_ids ), p_appl_ids ), v_ord ); ' ||
	    'prepare dynstmt from v_sql; open crsr; END';
    end if;
    execute immediate v_sql;
END
~

call ml_create_get_blocked_info_proc()
~

drop procedure ml_create_get_blocked_info_proc
~


--
-- Add new stored procedures for user authentication using LDAP servers
--
create procedure ml_add_ldap_server ( 
    in p_ldsrv_name	varchar( 128 ),
    in p_search_url    	varchar( 1024 ),
    in p_access_dn    	varchar( 1024 ),
    in p_access_dn_pwd	varchar( 256 ),
    in p_auth_url	varchar( 1024 ),
    in p_conn_retries	smallint,
    in p_conn_timeout	smallint,
    in p_start_tls	smallint ) 
MODIFIES SQL DATA 
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    declare v_sh_url	varchar( 1024 );
    declare v_as_dn	varchar( 1024 );
    declare v_as_pwd	varchar( 256 );
    declare v_au_url	varchar( 1024 );
    declare v_timeout	smallint;
    declare v_retries	smallint;
    declare v_tls	smallint;
    declare v_count	integer;
    declare v_ldsrv_id	integer;
    if p_ldsrv_name is not null then
	if p_search_url is null and
	    p_access_dn is null and
	    p_access_dn_pwd is null and
	    p_auth_url is null and
	    p_conn_timeout is null and
	    p_conn_retries is null and
	    p_start_tls is null then
	    
	    -- delete the server if it is not used
	    if not exists ( select * from ml_ldap_server s, ml_user_auth_policy p
		    where ( s.ldsrv_id = p.primary_ldsrv_id or
			    s.ldsrv_id = p.secondary_ldsrv_id ) and
			    s.ldsrv_name = p_ldsrv_name ) then
		delete from ml_ldap_server where ldsrv_name = p_ldsrv_name; 
	    end if;
	else
	    if not exists ( select * from ml_ldap_server
				where ldsrv_name = p_ldsrv_name ) then
		-- add a new ldap server
		if p_conn_timeout is null then
		    set v_timeout = 10;
		else
		    set v_timeout = p_conn_timeout;
		end if;
		if p_conn_retries is null then
		    set v_retries = 3;
		else
		    set v_retries = p_conn_retries;
		end if;
		if p_start_tls is null then
		    set v_tls = 0;
		else
		    set v_tls = p_start_tls;
		end if;
		
		insert into ml_ldap_server ( ldsrv_name, search_url,
			access_dn, access_dn_pwd, auth_url,
			timeout, num_retries, start_tls )
		    values( p_ldsrv_name, p_search_url,
			    p_access_dn, p_access_dn_pwd,
			    p_auth_url, v_timeout, v_retries, v_tls );
	    else
		-- update the ldat server info
		select search_url, access_dn, access_dn_pwd,
			auth_url, timeout, num_retries, start_tls
			into
			v_sh_url, v_as_dn, v_as_pwd,
			v_au_url, v_timeout, v_retries, v_tls
		    from ml_ldap_server where ldsrv_name = p_ldsrv_name;
		    
		if p_search_url is not null then
		    set v_sh_url = p_search_url;
		end if;
		if p_access_dn is not null then
		    set v_as_dn = p_access_dn;
		end if;
		if p_access_dn_pwd is not null then
		    set v_as_pwd = p_access_dn_pwd;
		end if;
		if p_auth_url is not null then
		    set v_au_url = p_auth_url;
		end if;
		if p_conn_timeout is not null then
		    set v_timeout = p_conn_timeout;
		end if;
		if p_conn_retries is not null then
		    set v_retries = p_conn_retries;
		end if;
		if p_start_tls is not null then
		    set v_tls = p_start_tls;
		end if;
		    
		update ml_ldap_server set
			search_url = v_sh_url,
			access_dn = v_as_dn,
			access_dn_pwd = v_as_pwd,
			auth_url = v_au_url,
			timeout = v_timeout,
			num_retries = v_retries,
			start_tls = v_tls
		where ldsrv_name = p_ldsrv_name;
	    end if;
	end if;
    end if;
end
~

create procedure ml_add_certificates_file (
    in p_file_name	varchar( 1024 ) )
MODIFIES SQL DATA 
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    if p_file_name is not null then
	delete from ml_trusted_certificates_file;
	insert into ml_trusted_certificates_file ( file_name )
	    values( p_file_name );
    end if;
end
~

create procedure ml_add_user_auth_policy (
    in p_policy_name			varchar( 128 ),
    in p_primary_ldsrv_name		varchar( 128 ),
    in p_secondary_ldsrv_name		varchar( 128 ),
    in p_ldap_auto_failback_period	integer,
    in p_ldap_failover_to_std		integer )
MODIFIES SQL DATA 
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    declare v_pldsrv_id	integer;
    declare v_sldsrv_id	integer;
    declare v_pid	integer;
    declare v_sid	integer;
    declare v_period	integer;
    declare v_failover	integer;
    declare v_error	integer;
    declare v_msg	varchar( 1024 );
    
    if p_policy_name is not null then
	if p_primary_ldsrv_name is null and 
	    p_secondary_ldsrv_name is null and 
	    p_ldap_auto_failback_period is null and 
	    p_ldap_failover_to_std is null then
	    
	    -- delete the policy name if not used
	    if not exists ( select * from ml_user u, ml_user_auth_policy p
				where u.policy_id = p.policy_id and
				      p.policy_name = p_policy_name ) then
		delete from ml_user_auth_policy
		    where policy_name = p_policy_name;
	    end if;
	elseif p_primary_ldsrv_name is null then
	    -- error
	    set v_msg = 'The primary LDAP server cannot be NULL.';
	    signal SQLSTATE '76001' set MESSAGE_TEXT = v_msg;
	else
	    set v_error = 0;
	    if p_primary_ldsrv_name is not null then
		select ldsrv_id into v_pldsrv_id from ml_ldap_server
				where ldsrv_name = p_primary_ldsrv_name;
		if v_pldsrv_id is null then
		    set v_error = 1;
		    set v_msg = 'Primary LDAP server "' CONCAT p_primary_ldsrv_name CONCAT '" is not defined.';
		    signal SQLSTATE '76002' set MESSAGE_TEXT = v_msg;
		end if;
	    else
		set v_pldsrv_id = null;
	    end if;
	    if p_secondary_ldsrv_name is not null then
		select ldsrv_id into v_sldsrv_id from ml_ldap_server
				where ldsrv_name = p_secondary_ldsrv_name;
		if v_sldsrv_id is null then
		    set v_error = 1;
		    set v_msg = 'Secondary LDAP server "' CONCAT p_secondary_ldsrv_name CONCAT '" is not defined.';
		    signal SQLSTATE '76003' set MESSAGE_TEXT = v_msg;
		end if;
	    else
		set v_sldsrv_id = null;
	    end if;
	    if v_error = 0 then
		if not exists ( select * from ml_user_auth_policy
				where policy_name = p_policy_name ) then
		    if p_ldap_auto_failback_period is null then
			set v_period = 900;
		    else
			set v_period = p_ldap_auto_failback_period;
		    end if;
		    if p_ldap_failover_to_std is null then
			set v_failover = 1;
		    else
			set v_failover = p_ldap_failover_to_std;
		    end if;
		    
		    -- add a new user auth policy
		    insert into ml_user_auth_policy
			( policy_name, primary_ldsrv_id, secondary_ldsrv_id,
			  ldap_auto_failback_period, ldap_failover_to_std )
			values( p_policy_name, v_pldsrv_id, v_sldsrv_id,
				v_period, v_failover );
		else
		    select primary_ldsrv_id, secondary_ldsrv_id,
			    ldap_auto_failback_period, ldap_failover_to_std
			    into
			    v_pid, v_sid, v_period, v_failover
			from ml_user_auth_policy where policy_name = p_policy_name;
    
		    if v_pldsrv_id is not null then
			set v_pid = v_pldsrv_id;
		    end if;
		    if v_sldsrv_id is not null then
			set v_sid = v_sldsrv_id;
		    end if;
		    if p_ldap_auto_failback_period is not null then
			set v_period = p_ldap_auto_failback_period;
		    end if;
		    if p_ldap_failover_to_std is not null then
			set v_failover = p_ldap_failover_to_std;
		    end if;

		    -- update the user auth policy
		    update ml_user_auth_policy set
				primary_ldsrv_id = v_pid,
				secondary_ldsrv_id = v_sid,
				ldap_auto_failback_period = v_period,
				ldap_failover_to_std = v_failover
			where policy_name = p_policy_name;
		end if;
	    end if;
	end if;
    end if;
end
~

--
-- Replace the ml_add_user stored procedure.
--
drop procedure ml_add_user
~

create procedure ml_add_user (
    in p_user		varchar( 128 ),
    in p_password	varchar( 32 ) for bit data,
    in p_policy_name	varchar( 128 ) ) 
MODIFIES SQL DATA 
CALLED ON NULL INPUT
LANGUAGE SQL
COMMIT ON RETURN NO
begin
    declare v_user_id	integer;
    declare v_policy_id	integer;
    declare v_error	integer;
    declare v_msg	varchar( 1024 );
    
    if p_user is not null then
	set v_error = 0;
	if p_policy_name is not null then
	    select policy_id into v_policy_id from ml_user_auth_policy
				where policy_name = p_policy_name;
	    if v_policy_id is null then
		set v_msg = 'Unable to find the user authentication policy: "' CONCAT p_policy_name CONCAT '".';
		signal SQLSTATE '76004' set MESSAGE_TEXT = v_msg;
		set v_error = 1;
	    end if;
	else 
	    set v_policy_id = null;
	end if;
	if v_error = 0 then
	    select user_id into v_user_id from ml_user where name = p_user;
	    if v_user_id is null then
		insert into ml_user ( name, hashed_password, policy_id )
		    values ( p_user, p_password, v_policy_id );
	    else
		update ml_user set hashed_password = p_password,
				    policy_id = v_policy_id
		    where user_id = v_user_id;
	    end if;
	end if;
    end if;
end
~

create procedure ml_delete_user( in p_user varchar( 128 ) )
    MODIFIES SQL DATA 
    CALLED ON NULL INPUT
    LANGUAGE SQL
    COMMIT ON RETURN NO
    BEGIN
      CALL ml_delete_user_state( p_user );
      delete from ml_user where name = p_user;
    END
~


---------------------------------------------------
--   Schema for ML Remote administration
---------------------------------------------------

create procedure ml_setup_proc ()
LANGUAGE SQL
BEGIN
    IF NOT EXISTS ( SELECT * FROM TABLE ( sysproc.env_get_inst_info() )
			WHERE service_level LIKE '%v9.5%' ) THEN
	CALL SET_ROUTINE_OPTS(GET_ROUTINE_OPTS() || 'CONCURRENTACCESSRESOLUTION WAIT FOR OUTCOME' );
    END IF;
END
~

CALL ml_setup_proc()
~

DROP PROCEDURE ml_setup_proc()
~

create table ml_ra_schema_name (
    schema_name                     varchar( 128 ) not null,
    remote_type                    varchar(1) not null,
    last_modified                  timestamp not null,
    description		           varchar( 2048 ),
    primary key (schema_name) 
)
~

create table ml_ra_agent (
    aid                            integer not null generated by default as identity (start with 1, increment by 1),
    agent_id                       varchar( 128 ) not null unique,
    taskdb_rid                     integer,
    primary key( aid ),
    foreign key( taskdb_rid ) references ml_database ( rid )
)
~
create index tdb_rid on ml_ra_agent( taskdb_rid ) 
~

create table ml_ra_task (
    task_id                        decimal( 20 ) not null generated by default as identity (start with 1, increment by 1),
    task_name                      varchar( 128 ) not null unique,
    schema_name			   varchar( 128 ),
    max_running_time               integer,
    max_number_of_attempts         integer,
    delay_between_attempts         integer,
    flags                          decimal( 20 ) not null,
    cond                           clob( 100K ),
    remote_event                   clob( 100K ),
    random_delay_interval	   integer not null default 0,
    primary key( task_id ), 
    foreign key( schema_name ) references ml_ra_schema_name( schema_name )
)
~

create table ml_ra_deployed_task (
    task_instance_id               decimal( 20 ) not null generated by default as identity (start with 1, increment by 1),
    aid                            integer not null,
    task_id                        decimal( 20 ) not null,
    assignment_time                timestamp not null default current timestamp,
    state                          varchar( 4 ) not null default 'P',
    previous_exec_count            decimal( 20 ) not null default 0,
    previous_error_count           decimal( 20 ) not null default 0,
    previous_attempt_count         decimal( 20 ) not null default 0,
    reported_exec_count            decimal( 20 ) not null default 0,
    reported_error_count           decimal( 20 ) not null default 0,
    reported_attempt_count         decimal( 20 ) not null default 0,
    last_modified                  timestamp not null,
    unique( aid, task_id ),
    primary key( task_instance_id ), 
    foreign key( aid ) references ml_ra_agent( aid ),
    foreign key( task_id ) references ml_ra_task( task_id )
)
~
create index dt_tid_idx on ml_ra_deployed_task( task_id )
~

create table ml_ra_task_command (
    task_id                        decimal( 20 ) not null,
    command_number                 integer not null,
    flags                          decimal( 20 ) not null default 0,
    action_type                    varchar( 4 ) not null,
    action_parm                    clob( 100K ), -- empty string may be null in db2 9.7 with oracle compatibility set
    primary key( task_id, command_number ),
    foreign key( task_id ) references ml_ra_task( task_id )
)
~

create table ml_ra_event (
    event_id                       decimal( 20 ) not null generated by default as identity (start with 1, increment by 1),
    event_class                    varchar( 4 ) not null,
    event_type                     varchar( 8 ) not null,
    aid	                           integer,
    task_id			   decimal( 20 ),
    command_number                 integer,
    run_number                     decimal( 20 ),
    duration                       integer,
    event_time                     timestamp not null,
    event_received                 timestamp not null default current timestamp,
    result_code                    decimal( 20 ),
    result_text                    clob( 100M ),
    primary key (event_id) 
)
~
create index ev_tn_idx on ml_ra_event( task_id )
~
create index ev_time_idx on ml_ra_event( event_received )
~
create index ev_agent_idx on ml_ra_event( aid )
~

create table ml_ra_event_staging (
    taskdb_rid			   integer not null,
    remote_event_id                decimal( 20 ) not null,
    event_class                    varchar( 4 ) not null,
    event_type                     varchar( 8 ) not null,
    task_instance_id               decimal( 20 ),
    command_number                 integer,
    run_number                     decimal( 20 ),
    duration                       integer,
    event_time                     timestamp not null,
    result_code                    decimal( 20 ),
    result_text                    clob( 100M ),
    primary key( taskdb_rid, remote_event_id ) 
)
~
create index evs_type_idx on ml_ra_event_staging( event_type )
~

create table ml_ra_notify (
    agent_poll_key                 varchar( 128 ) not null,
    task_instance_id               decimal( 20 ) not null,
    last_modified                  timestamp not null,
    primary key( agent_poll_key, task_instance_id ),
    foreign key( agent_poll_key ) references ml_ra_agent( agent_id )
)
~

create table ml_ra_task_property (
    task_id                        decimal( 20 ) not null,
    property_name                  varchar( 128 ) not null,
    last_modified                  timestamp not null,
    property_value                 clob( 100K ),
    primary key( property_name, task_id ), 
    foreign key( task_id ) references ml_ra_task( task_id )
)
~

create table ml_ra_task_command_property (
    task_id                        decimal( 20 ) not null,
    command_number                 integer not null,
    property_name                  varchar( 128 ) not null,
    property_value                 varchar( 2048 ),
    last_modified                  timestamp not null,
    primary key( task_id, command_number, property_name ), 
    foreign key( task_id, command_number ) references ml_ra_task_command( task_id, command_number )
)
~

create table ml_ra_managed_remote (
    mrid                           integer not null generated by default as identity (start with 1, increment by 1),
    remote_id                      varchar( 128 ),
    aid                            integer not null,
    schema_name			   varchar( 128 ) not null,
    conn_str		           varchar( 2048 ) not null,
    last_modified                  timestamp not null,
    unique( aid, schema_name ),
    primary key( mrid ),
    foreign key( aid ) references ml_ra_agent( aid ),
    foreign key( schema_name ) references ml_ra_schema_name( schema_name )
)
~

create table ml_ra_agent_property (
    aid                            integer not null,
    property_name                  varchar( 128 ) not null,
    property_value                 varchar( 2048 ),
    last_modified                  timestamp not null,
    primary key( aid, property_name ),
    foreign key( aid ) references ml_ra_agent( aid )
)
~

create table ml_ra_agent_staging (
    taskdb_rid		           integer not null,
    property_name                  varchar( 128 ) not null,
    property_value                 varchar( 2048 ),
    primary key( taskdb_rid, property_name ) 
)
~

-----------------------------------------------------------------
-- Stored procedures for Tasks
-----------------------------------------------------------------

-- Assign a remote task to a specific agent.

create procedure ml_ra_assign_task(
    p_agent_id		varchar( 128 ),  
    p_task_name		varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_task_id		decimal( 20 );
    declare v_task_instance_id	decimal( 20 );
    declare v_old_state		varchar( 4 );
    declare v_aid		integer;
    declare v_rid		integer;
    
    select task_id into v_task_id
	from ml_ra_task where task_name = p_task_name;
    if v_task_id is null then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad task name';
    end if;

    select aid into v_aid from ml_ra_agent where agent_id = p_agent_id;
    if v_aid is null then 
	signal SQLSTATE '99002' set MESSAGE_TEXT = 'bad agent id';
    end if;

    select state, task_instance_id into v_old_state, v_task_instance_id
	from ml_ra_deployed_task where task_id = v_task_id and aid = v_aid;
    if v_task_instance_id is null then
	insert into ml_ra_deployed_task( aid, task_id, last_modified ) 
	    values ( v_aid, v_task_id, current timestamp );
    elseif v_old_state != 'A' and v_old_state != 'P' then
	-- Re-activate the task
	update ml_ra_deployed_task 
	    set state = 'P',
	    previous_exec_count = reported_exec_count + previous_exec_count,
	    previous_error_count = reported_error_count + previous_error_count,
	    previous_attempt_count = reported_attempt_count + previous_attempt_count,
	    reported_exec_count = 0,
	    reported_error_count = 0,
	    reported_attempt_count = 0,
	    last_modified = current timestamp
	where task_instance_id = v_task_instance_id;
    end if;
    -- if the task is already active then do nothing 
end
~

create procedure ml_ra_int_cancel_notification(
    in p_agent_id		varchar( 128 ),
    in p_task_instance_id	decimal( 20 ),
    in p_request_time		timestamp ) 
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    delete from ml_ra_notify
	where agent_poll_key = p_agent_id
	    and task_instance_id = p_task_instance_id
	    and last_modified <= p_request_time;
end
~

create procedure ml_ra_cancel_notification(
    in p_agent_id		varchar( 128 ),
    in p_task_name		varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_task_instance_id	decimal( 20 );
    declare v_ts		timestamp;

    select task_instance_id into v_task_instance_id
	from ml_ra_agent
	    join ml_ra_deployed_task on ml_ra_deployed_task.aid = ml_ra_agent.aid
	    join ml_ra_task on ml_ra_deployed_task.task_id = ml_ra_task.task_id
	where agent_id = p_agent_id 
	    and task_name = p_task_name;

    set v_ts = current timestamp;
    call ml_ra_int_cancel_notification( p_agent_id, v_task_instance_id, v_ts );
end
~

create procedure ml_ra_cancel_task_instance(
    in p_agent_id	varchar( 128 ), 
    in p_task_name	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_task_id	decimal( 20 );
    declare v_aid	integer;

    select task_id into v_task_id
	from ml_ra_task where task_name = p_task_name;
    select ml_ra_agent.aid into v_aid
	from ml_ra_agent where agent_id = p_agent_id;
	
    if exists ( select * from ml_ra_deployed_task where aid = v_aid and
		task_id = v_task_id and ( state = 'A' or state = 'P' ) ) then
	update ml_ra_deployed_task
	    set state = 'CP', last_modified = current timestamp
	    where aid = v_aid and task_id = v_task_id 
		and ( state = 'A' or state = 'P' );
    else
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad task instance';
    end if;
    call ml_ra_cancel_notification( p_agent_id, p_task_name );
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_delete_task(
    in p_task_name	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_task_id	decimal( 20 );

    select task_id into v_task_id from ml_ra_task
	where task_name = p_task_name;
    if v_task_id is null then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad task name';
    end if;

    -- Only delete inactive instances, operation
    -- will fail if active instances exist.
    delete from ml_ra_deployed_task where task_id = v_task_id 
	and ( state != 'A' and state != 'P' and state != 'CP' );
    delete from ml_ra_task_command_property where task_id = v_task_id;
    delete from ml_ra_task_command where task_id = v_task_id;
    delete from ml_ra_task_property where task_id = v_task_id;
    delete from ml_ra_task where task_id = v_task_id;
end
~

-- result contains a row for each deployed instance of every task

create procedure ml_ra_get_task_status(
    in p_agent_id	varchar( 128 ),
    in p_task_name	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare p_crsr cursor with return to client for
	select agent_id,
	    mr.remote_id,
	    t.task_name,
	    t.task_id,
	    dt.state,
	    dt.reported_exec_count + dt.previous_exec_count,
	    dt.reported_error_count + dt.previous_error_count,
	    dt.reported_attempt_count + dt.previous_attempt_count,
	    dt.last_modified,
	    ( select max( event_time ) from ml_ra_event 
		where ml_ra_event.task_id = t.task_id ),
	    dt.assignment_time
	from ml_ra_task t 
	    join ml_ra_deployed_task dt on t.task_id = dt.task_id
	    join ml_ra_agent a on a.aid = dt.aid
	    left outer join ml_ra_managed_remote mr on mr.schema_name = t.schema_name
		and mr.aid = a.aid
	where
	    ( p_agent_id is null or a.agent_id = p_agent_id )
	    and ( p_task_name is null or t.task_name = p_task_name )
	order by agent_id, task_name;
    open p_crsr;
end
~

create procedure ml_ra_notify_agent_sync(
    in p_agent_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_aid	integer;

    select aid into v_aid from ml_ra_agent where agent_id = p_agent_id;
    if v_aid is null then
	return;
    end if;
    
    if exists (select * from ml_ra_notify where
		agent_poll_key = p_agent_id and task_instance_id = -1 ) then
	update ml_ra_notify set last_modified = current timestamp
	    where agent_poll_key = p_agent_id and task_instance_id = -1;
    else
	insert into ml_ra_notify( agent_poll_key, task_instance_id,
				  last_modified )
	    values( p_agent_id, -1, current timestamp );
    end if;
end
~

create procedure ml_ra_notify_task(
    in p_agent_id		varchar( 128 ), 
    in p_task_name		varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_task_instance_id	decimal( 20 );

    select task_instance_id into v_task_instance_id
	from ml_ra_agent
	    join ml_ra_deployed_task on ml_ra_deployed_task.aid = ml_ra_agent.aid
	    join ml_ra_task on ml_ra_deployed_task.task_id = ml_ra_task.task_id
	where agent_id = p_agent_id 
	    and task_name = p_task_name;
    if exists (select * from ml_ra_notify
		    where agent_poll_key = p_agent_id and
			task_instance_id = v_task_instance_id ) then
	update ml_ra_notify set last_modified = current timestamp
	    where agent_poll_key = p_agent_id and
		task_instance_id = v_task_instance_id;
    else
	insert into ml_ra_notify( agent_poll_key, task_instance_id,
				  last_modified )
	    values( p_agent_id, v_task_instance_id, current timestamp ); 
    end if;
end
~

create procedure ml_ra_get_latest_event_id(
    inout p_event_id	decimal( 20 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    select max( event_id ) into p_event_id from ml_ra_event;
end
~

create procedure ml_ra_get_agent_events(
    in p_start_at_event_id	decimal( 20 ), 
    in p_max_events_to_fetch	decimal( 20 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare p_crsr cursor with return to client for
    select 
	event_id, 
	event_class, 
	event_type,
	agent_id, 
	remote_id,
	task_name,
	command_number,
	run_number,
	duration,
	event_time, 
	event_received,
	result_code, 
	result_text 
    from ( select
	    row_number() over(order by event_id) as row_number,
	    event_id, 
	    event_class, 
	    event_type,
	    ml_ra_agent.agent_id, 
	    mr.remote_id,
	    t.task_name,
	    command_number,
	    run_number,
	    duration,
	    event_time, 
	    event_received,
	    result_code, 
	    result_text
	from ml_ra_event e
	    left outer join ml_ra_agent on ml_ra_agent.aid = e.aid
	    left outer join ml_ra_task t on t.task_id = e.task_id
	    left outer join ml_ra_managed_remote mr on 
		mr.schema_name = t.schema_name and mr.aid = ml_ra_agent.aid
	where
	    event_id >= p_start_at_event_id          
	order by event_id )
    where row_number <= p_max_events_to_fetch;
    open p_crsr;
end
~

create procedure ml_ra_get_task_results( 
    in p_agent_id		varchar( 128 ), 
    in p_task_name		varchar( 128 ),
    in p_run_number		integer )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare v_run_number	integer;
    declare v_aid		integer;
    declare v_remote_id		varchar(128);
    declare v_task_id		decimal(20);
    
    select aid into v_aid from ml_ra_agent where agent_id = p_agent_id;
    select task_id, remote_id into v_task_id, v_remote_id from ml_ra_task t
	left outer join ml_ra_managed_remote mr 
	    on mr.schema_name = t.schema_name and mr.aid = v_aid
	where task_name = p_task_name;
    if p_run_number is null then
	-- get the latest run
	select max( run_number ) into v_run_number from ml_ra_event
	    where ml_ra_event.aid = v_aid and
		ml_ra_event.task_id = v_task_id;
    else
	set v_run_number = p_run_number;
    end if;
    begin
	declare crsr cursor with return to client for
	    select 
		event_id, 
		event_class, 
		event_type,
		p_agent_id, 
		v_remote_id,
		p_task_name,
		command_number,
		run_number,
		duration,
		event_time, 
		event_received,
		result_code, 
		result_text
	    from ml_ra_event e
	    where e.aid = v_aid and
		e.task_id = v_task_id and
		e.run_number = v_run_number
	    order by event_id;
	open crsr;
    end;
end
~

-- Maintenance functions ----------------------------------

create procedure ml_ra_get_agent_ids()
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select agent_id, 
	    ( select max( last_download_time ) from ml_subscription mlsb
		where mlsb.rid = ml_ra_agent.taskdb_rid ), 
	    ( select max( last_upload_time ) from ml_subscription mlsb
		where mlsb.rid = ml_ra_agent.taskdb_rid ), 
	    ( select count(*) from ml_ra_deployed_task
		where ml_ra_deployed_task.aid = ml_ra_agent.aid
		  and (state = 'A' or state = 'P' or state = 'CP') ),
	    remote_id,
	    property_value
	from ml_ra_agent
	left outer join ml_database on ml_database.rid = taskdb_rid
	left outer join ml_ra_agent_property
	    on ml_ra_agent.aid = ml_ra_agent_property.aid
		and property_name = 'ml_ra_description'
	order by agent_id;
    open crsr;
end
~

create procedure ml_ra_get_remote_ids()
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select ml_database.remote_id,
	    schema_name,
	    agent.agent_id,
	    conn_str,
	    ( select max( last_download_time ) from ml_subscription mlsb where mlsb.rid = ml_database.rid ), 
	    ( select max( last_upload_time ) from ml_subscription mlsb where mlsb.rid = ml_database.rid ), 
	    description
	from ml_database 
	    left outer join ml_ra_managed_remote on ml_database.remote_id = ml_ra_managed_remote.remote_id
	    left outer join ml_ra_agent agent on agent.aid = ml_ra_managed_remote.aid
	    left outer join ml_ra_agent_staging s on s.taskdb_rid = ml_database.rid and property_name = 'agent_id'
	where property_value is null
	order by ml_database.remote_id;
    open crsr;
end
~

create procedure ml_ra_set_agent_property(
    in p_agent_id	varchar( 128 ),
    in p_property_name	varchar( 128 ),
    in p_property_value	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_cnt		    integer;
    declare v_aid		    integer;
    declare v_server_interval	    integer;
    declare v_old_agent_interval    integer;
    declare v_new_agent_interval    integer;
    declare v_autoset		    varchar(3);
    declare v_temp		    varchar(128);

    select aid into v_aid from ml_ra_agent where agent_id = p_agent_id;

    if p_property_name = 'lwp_freq' then
	select property_value into v_autoset from ml_property where 
	    component_name = 'SIRT'
	    and property_set_name = 'RTNotifier(RTNotifier1)'
	    and property_name = 'autoset_poll_every';
	if v_autoset = 'yes' then
	    select property_value into v_temp from ml_property where 
		component_name = 'SIRT'
		and property_set_name = 'RTNotifier(RTNotifier1)'
		and property_name = 'poll_every';
	    set v_server_interval = cast( v_temp as integer );
	    select cast( property_value as integer ) into v_old_agent_interval from ml_ra_agent_property where
		aid = v_aid
		and property_name = 'lwp_freq';
	    set v_new_agent_interval = cast( p_property_value as integer );
	    if v_new_agent_interval < v_server_interval then
		call ml_add_property( 'SIRT', 'RTNotifier(RTNotifier1)', 'poll_every', p_property_value );
	    elseif v_new_agent_interval > v_server_interval then
		if v_new_agent_interval > v_old_agent_interval and v_old_agent_interval <= v_server_interval then
		    -- This agents interval is increasing, check if server interval should increase too
		    if not exists( select * from ml_ra_agent_property 
			where property_name = 'lwp_freq'
			    and cast(property_value as integer) <= v_old_agent_interval
			    and aid != v_aid ) then
			-- Need to compute the new server interval
			select min( cast( property_value as integer ) ) into v_server_interval from ml_ra_agent_property 
			    where property_name = 'lwp_freq' and aid != v_aid;
			if v_server_interval is null then 
			    set v_server_interval = v_new_agent_interval;
			end if;
			call ml_add_property( 'SIRT', 'RTNotifier(RTNotifier1)', 'poll_every', cast( v_server_interval as char(128) ) );
		    end if;
		end if;
	    end if;
	end if;
    end if;	

    if exists (select * from ml_ra_agent_property
		where aid = v_aid and property_name = p_property_name) then
	update ml_ra_agent_property
	    set property_value = p_property_value,
		last_modified = current timestamp
	    where aid = v_aid and property_name = p_property_name;
    else
	insert into ml_ra_agent_property( aid, property_name,
					  property_value, last_modified )
	    values( v_aid, p_property_name, p_property_value, current timestamp );
    end if;
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_clone_agent_properties(
    in p_dst_agent_id	varchar( 128 ),
    in p_src_agent_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_dst_aid	integer;
    declare v_src_aid	integer;

    select aid into v_dst_aid from ml_ra_agent where agent_id = p_dst_agent_id;
    select aid into v_src_aid from ml_ra_agent where agent_id = p_src_agent_id;
    if v_src_aid is null then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad src';
    end if;

    delete from ml_ra_agent_property
	where aid = v_dst_aid
	    and property_name != 'agent_id'
	    and property_name not like 'ml+_ra+_%' escape '+';

    insert into ml_ra_agent_property( aid, property_name, property_value, last_modified )
	select v_dst_aid, src.property_name, src.property_value, current timestamp 
	from ml_ra_agent_property src 
	where src.aid = v_src_aid 
	    and property_name != 'agent_id' 
	    and property_name not like 'ml+_ra+_%' escape '+';
end
~

create procedure ml_ra_get_agent_properties(
    in p_agent_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare v_aid	integer;

    select aid into v_aid from ml_ra_agent where agent_id = p_agent_id;
    
    begin
	declare crsr cursor with return to client for
	    select property_name, property_value, last_modified
	    from ml_ra_agent_property 
	    where aid = v_aid
		and property_name != 'agent_id'
		and property_name not like 'ml+_ra+_%' escape '+'
	    order by property_name;
	open crsr;
    end;
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_add_agent_id(
    in p_agent_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_aid	 integer;

    insert into ml_ra_agent( agent_id ) values ( p_agent_id );
    set v_aid = identity_val_local();

    insert into ml_ra_event( event_class, event_type, aid, event_time ) 
	values( 'I', 'ANEW', v_aid, current timestamp );
    call ml_ra_set_agent_property( p_agent_id, 'agent_id', p_agent_id );
    call ml_ra_set_agent_property( p_agent_id, 'max_taskdb_sync_interval', '86400' );
    call ml_ra_set_agent_property( p_agent_id, 'lwp_freq', '900' );
    call ml_ra_set_agent_property( p_agent_id, 'agent_id_status', 'OK' );
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_manage_remote_db(
    in p_agent_id		varchar( 128 ), 
    in p_schema_name		varchar( 128 ),
    in p_conn_str		varchar( 2048 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_aid	 integer;
    declare v_ldt	 timestamp;

    select aid, last_download_time into v_aid, v_ldt from 
	ml_ra_agent left outer join ml_subscription on taskdb_rid = rid
    where agent_id = p_agent_id;
    insert into ml_ra_managed_remote(aid, remote_id, schema_name, conn_str, last_modified ) 
	values( v_aid, null, p_schema_name, p_conn_str, current timestamp );

    update ml_ra_deployed_task dt set state = 'A' 
	where aid = v_aid and state = 'P' and last_modified < v_ldt
	    and exists( select * from ml_ra_task t where t.task_id = dt.task_id and t.schema_name = p_schema_name );
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_unmanage_remote_db(
    in p_agent_id		varchar( 128 ),
    in p_schema_name		varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_aid		integer;

    select aid into v_aid from ml_ra_agent where agent_id = p_agent_id;

    if exists (select * from ml_ra_deployed_task dt
		    join ml_ra_task t on dt.task_id = t.task_id
		    where dt.aid = v_aid and
			t.schema_name = p_schema_name
			and (state = 'A' or state = 'P' or state = 'CP') ) then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'has active tasks';
    else
	delete from ml_ra_deployed_task
	    where aid = v_aid and state != 'A' and state != 'P' and state != 'CP'
		and exists( select * from ml_ra_task where ml_ra_task.task_id = ml_ra_deployed_task.task_id
		    and ml_ra_task.schema_name = p_schema_name );
	delete from ml_ra_managed_remote where aid = v_aid and schema_name = p_schema_name;
    end if;
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_delete_agent_id(
    in p_agent_id		varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare SQLCODE		integer default 0;
    declare v_aid		integer;
    declare v_taskdb_rid	integer;
    declare v_taskdb_remote_id	varchar( 128 );
    declare taskdb_crsr		cursor for
	select taskdb_rid, ml_database.remote_id from ml_ra_agent_staging
	    join ml_database on ml_database.rid = taskdb_rid
	    where property_name = 'agent_id' and property_value = p_agent_id
	    for read only;

    select aid, taskdb_rid into v_aid, v_taskdb_rid
	from ml_ra_agent where agent_id = p_agent_id;
    if v_aid is null then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad agent id';
    end if;

    call ml_ra_set_agent_property( p_agent_id, 'lwp_freq', '2147483647' );

    -- Delete all dependent rows
    delete from ml_ra_agent_property where aid = v_aid;
    delete from ml_ra_deployed_task where aid = v_aid;
    delete from ml_ra_notify where agent_poll_key = p_agent_id;
    delete from ml_ra_managed_remote where aid = v_aid;

    -- Delete the agent
    delete from ml_ra_agent where aid = v_aid;

    -- Clean up any taskdbs that were associated with this agent_id
    open taskdb_crsr;
    fetch_loop: loop
	fetch taskdb_crsr into v_taskdb_rid, v_taskdb_remote_id;
	if SQLCODE = 100 then
	    leave fetch_loop;
	end if;
	delete from ml_ra_agent_staging where taskdb_rid = v_taskdb_rid;
	delete from ml_ra_event_staging where taskdb_rid = v_taskdb_rid;
	call ml_delete_remote_id( v_taskdb_remote_id );
    end loop;
    close taskdb_crsr;
end
~

create procedure ml_ra_int_move_events(
    in p_aid		integer, 
    in p_taskdb_rid	integer )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    -- Copy events into ml_ra_event from staging table
    insert into ml_ra_event( event_class, event_type, aid, task_id,
			     command_number, run_number, duration, event_time,
			     event_received, result_code, result_text )
	select event_class, event_type, p_aid, dt.task_id,
	       command_number, run_number, duration, event_time,
	       current timestamp, result_code, result_text
	    from ml_ra_event_staging es
		left outer join ml_ra_deployed_task dt on dt.task_instance_id = es.task_instance_id
	    where es.taskdb_rid = p_taskdb_rid
	    order by remote_event_id;

    -- Clean up staged values
    delete from ml_ra_event_staging where taskdb_rid = p_taskdb_rid;
end
~

create procedure ml_ra_delete_events_before(
    in p_delete_rows_older_than	timestamp )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    delete from ml_ra_event where event_received <= p_delete_rows_older_than;
end
~

create procedure ml_ra_get_orphan_taskdbs()
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select remote_id, property_value,
	    ( select max( last_upload_time ) from ml_subscription mlsb
		where mlsb.rid = ml_database.rid ) 
	from ml_database 
	    left outer join ml_ra_agent agent on agent.taskdb_rid = rid
	    left outer join ml_ra_agent_staging s on s.taskdb_rid = rid
		and property_name = 'agent_id'
	where property_value is not null and agent_id is null
	order by remote_id;
    open crsr;
end
~

-- If error is raised then caller must rollback

create procedure ml_ra_reassign_taskdb(
    in p_taskdb_remote_id	varchar( 128 ),
    in p_new_agent_id		varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_other_taskdb_rid	integer;
    declare v_taskdb_rid	integer;
    declare v_other_agent_aid	integer;
    declare v_old_agent_id	varchar( 128 );
    declare v_new_aid		integer;

    select rid into v_taskdb_rid from ml_database
	where remote_id = p_taskdb_remote_id;
    if v_taskdb_rid is null then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad remote';
    end if;

    select property_value into v_old_agent_id from ml_ra_agent_staging
	where taskdb_rid = v_taskdb_rid and
	property_name = 'agent_id';
    if v_old_agent_id is null then
	signal SQLSTATE '99001' set MESSAGE_TEXT = 'bad remote';
    end if;

    select count(*) into v_other_taskdb_rid from ml_ra_agent
	where agent_id = p_new_agent_id;
    if v_other_taskdb_rid = 0 then
	call ml_ra_add_agent_id( p_new_agent_id );
    end if;
    -- if v_other_taskdb_rid is not null then it becomes a new orphan taskdb

    -- If the taskdb isn't already orphaned then break the link with its original agent_id
    update ml_ra_agent set taskdb_rid = null where taskdb_rid = v_taskdb_rid;

    update ml_ra_agent_staging set property_value = p_new_agent_id
	where taskdb_rid = v_taskdb_rid
	    and property_name = 'agent_id';

    -- Preserve any events that have been uploaded
    -- Note, no task state is updated here, these
    -- events are stale and may no longer apply.
    select aid into v_new_aid from ml_ra_agent where agent_id = p_new_agent_id;
    call ml_ra_int_move_events( v_new_aid, v_taskdb_rid );

    -- The next time the agent syncs it will receive its new agent_id
    call ml_ra_notify_agent_sync( v_old_agent_id );
end
~

-----------------------------------------------------------------
-- Synchronization scripts for the remote agent's task database
-- Note, there is no authenticate user script here, this will need
-- to be provided by the user.
-----------------------------------------------------------------

create procedure ml_ra_ss_end_upload( 
    in p_taskdb_remote_id	varchar( 128 ) )
begin atomic
    declare SQLCODE			integer default 0;
    declare v_taskdb_rid		integer;
    declare v_consdb_taskdb_rid		integer;
    declare v_consdb_taskdb_remote_id 	varchar( 128 );
    declare v_agent_id			varchar( 128 );
    declare v_provided_id 		varchar( 128 );
    declare v_old_machine_name		varchar( 128 );
    declare v_new_machine_name		varchar( 128 );
    declare v_aid			integer;
    declare v_used			varchar( 128 );
    declare v_name			varchar( 128 );
    declare v_value			varchar( 2048 );
    declare v_old_value			varchar( 2048 );
    declare v_schema_name		varchar( 128 );
    declare v_cnt			integer;

    declare v_task_instance_id		decimal( 20 );
    declare v_result_code		decimal( 20 );
    declare v_event_type		varchar( 8 );
    declare event_crsr			cursor for
	    select event_type, result_code, result_text, task_instance_id
		from ml_ra_event_staging
		where taskdb_rid = v_taskdb_rid
		order by remote_event_id;
    declare as_crsr			cursor for
	    select property_name, property_value
		from ml_ra_agent_staging
		where taskdb_rid = v_taskdb_rid and
		    property_name not like 'ml+_ra+_%' escape '+';
		    
    select rid, agent_id, aid into v_taskdb_rid, v_agent_id, v_aid
	from ml_database left outer join ml_ra_agent on taskdb_rid = rid 
	where remote_id = p_taskdb_remote_id;

    if v_agent_id is null then 
	-- This taskdb isn't linked to an agent_id in the consolidated yet
	delete from ml_ra_agent_staging where taskdb_rid = v_taskdb_rid and property_name = 'agent_id_status';
	select property_value into v_provided_id from ml_ra_agent_staging 
	    where taskdb_rid = v_taskdb_rid and
		property_name = 'agent_id';
	if v_provided_id is null then
	    -- Agent failed to provide an agent_id
	    insert into ml_ra_agent_staging( taskdb_rid,
		    property_name, property_value )
		    values( v_taskdb_rid, 'agent_id_status', 'RESET' );
	    return;
	end if;
	    
	select taskdb_rid, aid into v_consdb_taskdb_rid, v_aid
	    from ml_ra_agent where agent_id = v_provided_id;
	if v_consdb_taskdb_rid is not null then
	    -- We have 2 remote task databases using the same agent_id.
	    -- Attempt to determine if its a reset of an agent or 2 separate 
	    -- agents conflicting with each other.
	    select remote_id into v_consdb_taskdb_remote_id
		from ml_database where rid = v_consdb_taskdb_rid;
	    set v_old_machine_name = substr( v_consdb_taskdb_remote_id, 7,
				     length(v_consdb_taskdb_remote_id) - 43 );
	    set v_new_machine_name = substr( p_taskdb_remote_id, 7,
				     length(p_taskdb_remote_id) - 43 );
		
	    if v_old_machine_name != v_new_machine_name then
		-- There are 2 agents with conflicting agent_ids
		-- This taskdb will not be allowed to download tasks.
		insert into ml_ra_event( event_class, event_type, aid,
					 event_time, result_text ) 
		    values( 'E', 'ADUP', v_aid, current timestamp,
			    p_taskdb_remote_id );
		insert into ml_ra_agent_staging( taskdb_rid,
			property_name, property_value )
			values( v_taskdb_rid, 'agent_id_status', 'DUP' );
		return;
	    end if; -- Otherwise, we allow replacement of the taskdb
	end if;	    

	set v_agent_id = v_provided_id;
	if v_aid is null then
	    -- We have a new agent_id
	    call ml_ra_add_agent_id( v_agent_id );
	    select aid into v_aid from ml_ra_agent where agent_id = v_agent_id;
	end if;

	select property_value into v_used from ml_ra_agent_staging 
	    where taskdb_rid = v_taskdb_rid and
		property_name = 'ml_ra_used';
	if v_used is not null then
	    -- We can only establish a mapping between new taskdb_remote_ids and agent_ids
	    insert into ml_ra_agent_staging( taskdb_rid,
		    property_name, property_value )
		    values( v_taskdb_rid, 'agent_id_status', 'RESET' );
	    -- Preserve any events that may have been uploaded
	    -- Note, no task state is updated here, these
	    -- events could be stale and may no longer apply.
	    call ml_ra_int_move_events( v_aid, v_taskdb_rid );
	    return;
	else
	    insert into ml_ra_agent_staging( taskdb_rid, property_name,
					     property_value )
		values( v_taskdb_rid, 'ml_ra_used', '1' );
	end if;

	-- Store the link between this agent_id and remote_id
	update ml_ra_agent set taskdb_rid = v_taskdb_rid
	    where agent_id = v_agent_id;

	select property_value into v_used from ml_ra_agent_property
	    where aid = v_aid and property_name = 'ml_ra_used';
	if v_used is null then
	    -- This is the first taskdb for an agent
	    insert into ml_ra_event( event_class, event_type, aid,
				     event_time ) 
		values( 'I', 'AFIRST', v_aid, current timestamp );
	    insert into ml_ra_agent_property( aid, property_name,
					      property_value, last_modified )
		values( v_aid, 'ml_ra_used', '1', current timestamp );
	else
	    -- A new taskdb is taking over
	    insert into ml_ra_event( event_class, event_type, aid,
				     event_time, result_text ) 
		values( 'I', 'ARESET', v_aid, current timestamp,
			v_consdb_taskdb_remote_id );

	    update ml_ra_deployed_task
		set state = ( case state 
			when 'A' then 'P'
			when 'CP' then 'C'
			else state end ),
		    previous_exec_count = reported_exec_count + previous_exec_count,
		    previous_error_count = reported_error_count + previous_error_count,
		    previous_attempt_count = reported_attempt_count + previous_attempt_count,
		    reported_exec_count = 0,
		    reported_error_count = 0,
		    reported_attempt_count = 0,
		    last_modified = current timestamp
		where aid = v_aid;
	end if;
    end if;

    -- Update the status of deployed tasks
    open event_crsr;
    event_loop: loop
	fetch event_crsr into v_event_type, v_result_code, v_value, v_task_instance_id;
	if SQLCODE = 100 then
	    leave event_loop;
	end if;
	if v_event_type like 'TI%' or v_event_type like 'TF%' then
	    update ml_ra_deployed_task dt 
		set reported_exec_count = 
			( case when v_event_type = 'TIE' then
			    v_result_code else reported_exec_count end ),
		    reported_error_count = 
			( case when v_event_type = 'TIF' then
			    v_result_code else reported_error_count end ),
		    reported_attempt_count = 
			( case when v_event_type = 'TIA' then
			    v_result_code else reported_attempt_count end ),
		    state = 
			( case when v_event_type like('TF%') then
			    substr( v_event_type, 3, length( v_event_type ) - 2 )
			  else 
			    state
			  end )
		where dt.task_instance_id = v_task_instance_id;
	end if;

	-- Store any updated remote_ids
	if v_event_type = 'TRID' then
	    select t.schema_name into v_schema_name from ml_ra_deployed_task dt
		join ml_ra_task t on t.task_id = dt.task_id
		where dt.task_instance_id = v_task_instance_id;
	    update ml_ra_managed_remote set remote_id = v_value
		where aid = v_aid and schema_name = v_schema_name;
	end if;

	-- Update remote schema names
	if v_event_type = 'CR' and v_value like 'CHSN:%' then
	    set v_value = substr( v_value, 6, length( v_value ) - 5 );
	    select t.schema_name into v_schema_name from ml_ra_deployed_task dt
		join ml_ra_task t on t.task_id = dt.task_id
		where dt.task_instance_id = v_task_instance_id;
	    update ml_ra_managed_remote set schema_name = v_value
		where aid = v_aid and schema_name = v_schema_name
		    and exists( select * from ml_ra_schema_name where schema_name = v_value );
		
	    -- Old tasks go back to pending after schema name change
	    update ml_ra_deployed_task dt set state = 'P' 
		where dt.aid = v_aid and state = 'A'
		    and exists( select * from ml_ra_task t left outer join ml_ra_managed_remote mr
			    on t.schema_name = mr.schema_name and mr.aid = v_aid
			    where t.task_id = dt.task_id
				and t.schema_name is not null 
				and mr.schema_name is null );
	end if;
    end loop;
    close event_crsr;
   
    -- TI status rows are not true events
    delete from ml_ra_event_staging
    	where taskdb_rid = v_taskdb_rid and event_type like 'TI%';

    -- Process SIRT ack
    delete from ml_ra_notify
	where exists( select * from ml_ra_event_staging 
	    where taskdb_rid = v_taskdb_rid and event_type like 'TS%'
	    and ml_ra_notify.task_instance_id = ml_ra_event_staging.task_instance_id 
	    and last_modified <= event_time );

    delete from ml_ra_notify where agent_poll_key = v_agent_id and task_instance_id != -1 
	and not exists(	select * from ml_ra_deployed_task where
	    ml_ra_deployed_task.task_instance_id = ml_ra_notify.task_instance_id );

    -- Get properties from the agent
    open as_crsr;
    as_loop: loop
	fetch as_crsr into v_name, v_value;
	if SQLCODE = 100 then
	    leave as_loop;
	end if;
	if not exists (select * from ml_ra_agent_property
		where aid = v_aid and property_name = v_name) then
	    insert into ml_ra_agent_property( aid, property_name,
					      property_value, last_modified )
		values( v_aid, v_name, v_value, current timestamp );
	else
	    select property_value into v_old_value from ml_ra_agent_property
		where aid = v_aid and property_name = v_name;
	    if (v_old_value is null and v_value is not null )
		    or (v_old_value is not null and v_value is null )
		    or (v_old_value != v_value) then
		update ml_ra_agent_property set property_value = v_value, last_modified = current timestamp
		    where aid = v_aid and property_name = v_name;
	    end if;
	end if;
    end loop;
    close as_crsr;

    delete from ml_ra_agent_staging where taskdb_rid = v_taskdb_rid 
	and property_name not like 'ml+_ra+_%' escape '+'
	and property_name != 'agent_id';
    call ml_ra_int_move_events( v_aid, v_taskdb_rid );
end
~

create procedure ml_ra_ss_download_prop(
    in p_taskdb_remote_id	varchar( 128 ), 
    in p_last_table_download	timestamp )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare v_aid			integer;
    declare v_taskdb_rid		integer;

    select a.aid, d.rid into v_aid, v_taskdb_rid from ml_database d 
	left outer join ml_ra_agent a on a.taskdb_rid = d.rid
	where d.remote_id = p_taskdb_remote_id;

    if v_aid is null then
	begin
	    declare crsr cursor with return to client for
		select property_name, property_value from ml_ra_agent_staging 
		    where taskdb_rid = v_taskdb_rid 
			and property_name not like 'ml+_ra+_%' escape '+';
	    open crsr;
	end;
    else
	begin
	    declare crsr cursor with return to client for
		select property_name, property_value from ml_ra_agent_property p 
		    where p.aid = v_aid and property_name not like 'ml+_ra+_%' escape '+' 
			and last_modified >= p_last_table_download;
	    open crsr;
	end;
    end if;
end
~

create procedure ml_ra_ss_upload_prop(
    in p_taskdb_remote_id	varchar( 128 ), 
    in p_property_name		varchar( 128 ), 
    in p_property_value		varchar( 2048 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_cnt		integer;
    declare v_taskdb_rid	integer;

    select rid into v_taskdb_rid from ml_database where remote_id = p_taskdb_remote_id;
    if exists ( select * from ml_ra_agent_staging 
	    where taskdb_rid = v_taskdb_rid and property_name = p_property_name ) then
	update ml_ra_agent_staging set property_value = p_property_value
	    where taskdb_rid = v_taskdb_rid and property_name = p_property_name;
    else
	insert into ml_ra_agent_staging( taskdb_rid, property_name, property_value )
	    values( v_taskdb_rid, p_property_name, p_property_value );
    end if;
end
~

create procedure ml_ra_ss_download_task(
    in p_taskdb_remote_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select task_instance_id, task_name, ml_ra_task.schema_name,
	    max_number_of_attempts, delay_between_attempts,
	    max_running_time, ml_ra_task.flags,
	    case dt.state 
		when 'P' then 'A'
		when 'CP' then 'C'
	    end,
	    cond, remote_event
	from ml_database task_db
	    join ml_ra_agent on ml_ra_agent.taskdb_rid = task_db.rid
	    join ml_ra_deployed_task dt on dt.aid = ml_ra_agent.aid
	    join ml_ra_task on dt.task_id = ml_ra_task.task_id
	where task_db.remote_id = p_taskdb_remote_id
	    and ( dt.state = 'CP' or dt.state = 'P' );
    open crsr;
end
~

create procedure ml_ra_ss_download_task_cmd(
    in p_taskdb_remote_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select task_instance_id, command_number, ml_ra_task_command.flags,
	    action_type, action_parm
	from ml_database task_db
	    join ml_ra_agent on ml_ra_agent.taskdb_rid = task_db.rid
	    join ml_ra_deployed_task dt on dt.aid = ml_ra_agent.aid
	    join ml_ra_task on dt.task_id = ml_ra_task.task_id
	    join ml_ra_task_command on dt.task_id = ml_ra_task_command.task_id
	where task_db.remote_id = p_taskdb_remote_id
	    and dt.state = 'P';
    open crsr;
end
~

create procedure ml_ra_ss_download_remote_dbs(
    in p_taskdb_remote_id	varchar( 128 ),
    in p_last_download		timestamp )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select ml_ra_schema_name.schema_name, ml_ra_managed_remote.remote_id, conn_str, remote_type 
	from ml_database taskdb
	    join ml_ra_agent on ml_ra_agent.taskdb_rid = taskdb.rid
	    join ml_ra_managed_remote on ml_ra_managed_remote.aid = ml_ra_agent.aid
	    join ml_ra_schema_name on ml_ra_schema_name.schema_name = ml_ra_managed_remote.schema_name
	where taskdb.remote_id = p_taskdb_remote_id
	    and ml_ra_managed_remote.last_modified >= p_last_download;
    open crsr;
end
~

create procedure ml_ra_ss_upload_event(
    in p_taskdb_remote_id	varchar( 128 ), 
    in p_remote_event_id	decimal( 20 ), 
    in p_event_class		varchar( 1 ), 
    in p_event_type		varchar( 4 ), 
    in p_task_instance_id	decimal( 20 ), 
    in p_command_number		integer, 
    in p_run_number		decimal( 20 ), 
    in p_duration		integer,
    in p_event_time		timestamp,
    in p_result_code		decimal( 20 ), 
    in p_result_text		clob( 100M ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_task_name		varchar( 128 );
    declare v_cnt		integer;
    declare v_taskdb_rid	integer;

    select rid into v_taskdb_rid from ml_database where remote_id = p_taskdb_remote_id;
	
    if not exists (select * from ml_ra_event_staging
	    where taskdb_rid = v_taskdb_rid and
		remote_event_id = p_remote_event_id) then
	insert into ml_ra_event_staging( taskdb_rid, remote_event_id, 
		event_class, event_type, task_instance_id,
		command_number, run_number, duration, event_time,
		result_code, result_text )
	    values ( v_taskdb_rid, p_remote_event_id, p_event_class,
		p_event_type, p_task_instance_id, p_command_number,
		p_run_number, p_duration, p_event_time, p_result_code,
		p_result_text );
    end if;
end
~

create procedure ml_ra_ss_download_ack(
    in p_taskdb_remote_id	varchar( 128 ), 
    in p_ldt			timestamp )
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare SQLCODE		integer default 0;
    declare v_aid		integer;
    declare v_agent_id		varchar( 128 );
    declare v_task_instance_id	decimal( 20 );
    declare task_ack cursor for
	select dt.task_instance_id from ml_ra_deployed_task dt
	    join ml_ra_task t on t.task_id = dt.task_id
	    left outer join ml_ra_managed_remote mr
		on t.schema_name = mr.schema_name and mr.aid = v_aid
	where dt.aid = v_aid
	    and dt.state = 'P' and dt.last_modified < p_ldt
	    and ( t.schema_name is null or mr.schema_name is not null ); 

    select aid, agent_id into v_aid, v_agent_id from ml_ra_agent
	join ml_database on taskdb_rid = rid
	where remote_id = p_taskdb_remote_id;

    open task_ack;
    fetch_loop: loop
	fetch task_ack into v_task_instance_id;
	if SQLCODE = 100 then
	    leave fetch_loop;	    
	end if;
	update ml_ra_deployed_task set state = 'A' 
	    where task_instance_id = v_task_instance_id;
    end loop;
    close task_ack;

    if v_aid is not null then
	delete from ml_ra_notify where agent_poll_key = v_agent_id
		and task_instance_id = -1 and last_modified <= p_ldt;
	set v_aid = null; -- clear any sql warning
    end if;
end
~

-- Default file transfer scripts for upload and download

create procedure ml_ra_ss_agent_auth_file_xfer(
    in p_requested_direction	varchar( 128 ),
    inout p_auth_code		INTEGER,
    in p_ml_user		varchar( 128 ),
    in p_remote_key		varchar( 128 ),
    in p_fsize			decimal( 20 ),
    inout p_filename		varchar( 128 ),
    inout p_sub_dir		varchar( 128 ) )  
modifies SQL data
called on NULL input
language SQL
commit on return no
begin atomic
    declare v_offset		integer;
    declare v_cmd_num		integer;
    declare v_tiid		decimal( 20 );
    declare v_tid		decimal( 20 );
    declare v_aid		integer;
    declare v_task_state	varchar( 4 );
    declare v_max_size		decimal( 20 );
    declare v_direction		varchar( 1 );
    declare v_server_sub_dir	varchar( 128 );
    declare v_server_filename	varchar( 128 );
    declare v_agent_id		varchar( 128 );

    -- By convention file transfer commands will send up the remote key with...
    -- task_instance_id command_number
    -- eg 1 5	-- task_instance_id=1 command_number=5
    set v_offset = locate( ' ', p_remote_key );
    if v_offset = 0 then
	set p_auth_code = 2000;
	return;
    end if;

    set v_tiid = cast( substr( p_remote_key, 1, v_offset ) as int );
    set v_cmd_num = cast( substr( p_remote_key, v_offset + 1,
		length( p_remote_key ) - v_offset ) as int );
    if v_tiid is null or v_tiid < 1 or v_cmd_num is null or v_cmd_num < 0 then
	set p_auth_code = 2000;
	return;
    end if;

    -- fetch properties of the task
    select task_id, aid, state into v_tid, v_aid, v_task_state
	from ml_ra_deployed_task where task_instance_id = v_tiid;
    -- Disallow transfer if the task is no longer active
    if v_task_state is null or (v_task_state != 'A' and v_task_state != 'P') then
	set p_auth_code = 2001;
	return;
    end if;

    -- Make sure the file isn't too big
    select cast( property_value as decimal ) into v_max_size from ml_ra_task_command_property
	where task_id = v_tid and
	    command_number = v_cmd_num and
	    property_name = 'mlft_max_file_size';
    if v_max_size > 0 and p_fsize > v_max_size then
	set p_auth_code = 2002;
	return;
    end if;

    -- Make sure the direction is correct
    select property_value into v_direction from ml_ra_task_command_property
	where task_id = v_tid and
	    command_number = v_cmd_num and
	    property_name = 'mlft_transfer_direction';
    if v_direction != p_requested_direction then
	set p_auth_code = 2003;
	return;
    end if;

    -- set the filename output parameter
    select property_value into v_server_filename from ml_ra_task_command_property
	where task_id = v_tid and
	    command_number = v_cmd_num and
	    property_name = 'mlft_server_filename';
    if v_server_filename is not null then
	select agent_id into v_agent_id from ml_ra_agent where aid = v_aid;
	set p_filename = replace(
	    replace( v_server_filename, '{ml_username}', p_ml_user ),
	    '{agent_id}', v_agent_id );
    end if;
			
    -- set the sub_dir output parameter
    select property_value into v_server_sub_dir from ml_ra_task_command_property
	where task_id = v_tid and
	    command_number = v_cmd_num and
	    property_name = 'mlft_server_sub_dir';
    if v_server_sub_dir is null then
	set p_sub_dir = '';
    else
	select agent_id into v_agent_id from ml_ra_agent where aid = v_aid;
	set p_sub_dir = replace(
	    replace( v_server_sub_dir, '{ml_username}', p_ml_user ),
	    '{agent_id}', v_agent_id );
    end if;

    -- Everything is ok, allow the file transfer
    set p_auth_code = 1000;
end
~

call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_adminprop', 'upload_insert', 
'{ call ml_ra_ss_upload_prop( {ml s.remote_id}, {ml r.name}, {ml r.value} ) }' )    
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_adminprop', 'upload_update', 
'{ call ml_ra_ss_upload_prop( {ml s.remote_id}, {ml r.name}, {ml r.value} ) }' )    
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_adminprop', 'download_cursor', 
    '{call ml_ra_ss_download_prop( {ml s.remote_id}, {ml s.last_table_download} )}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_adminprop', 'download_delete_cursor', '--{ml_ignore}' )
~
call ml_add_connection_script( 'ml_ra_agent_12', 'end_upload', 
    '{call ml_ra_ss_end_upload( {ml s.remote_id} )}' )
~
call ml_add_connection_script( 'ml_ra_agent_12', 'nonblocking_download_ack', 
    '{call ml_ra_ss_download_ack( {ml s.remote_id}, {ml s.last_download} )}' )
~

call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_task', 'download_cursor', 
    '{call ml_ra_ss_download_task( {ml s.remote_id} )}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_task', 'download_delete_cursor', '--{ml_ignore}' )
~

call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_command', 'download_cursor',
    '{call ml_ra_ss_download_task_cmd( {ml s.remote_id} )}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_command', 'download_delete_cursor', '--{ml_ignore}' )
~

call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_remote_db', 'download_cursor',
    '{call ml_ra_ss_download_remote_dbs( {ml s.remote_id}, {ml s.last_table_download} )}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_remote_db', 'download_delete_cursor', '--{ml_ignore}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_remote_db', 'upload_insert', '--{ml_ignore}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_remote_db', 'upload_update', '--{ml_ignore}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_remote_db', 'upload_delete', '--{ml_ignore}' )
~

call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_status', 'upload_insert', 
    '{call ml_ra_ss_upload_event( 
    {ml s.remote_id}, {ml r.id}, {ml r.class}, {ml r.status}, 
    {ml r.task_instance_id}, {ml r.command_number}, {ml r.exec_count}, 
    {ml r.duration}, {ml r.status_time}, {ml r.status_code}, {ml r.text} )}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_status', 'upload_update', 
    '{call ml_ra_ss_upload_event( 
    {ml s.remote_id}, {ml r.id}, {ml r.class}, {ml r.status}, 
    {ml r.task_instance_id}, {ml r.command_number}, {ml r.exec_count}, 
    {ml r.duration}, {ml r.status_time}, {ml r.status_code}, {ml r.text} )}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_status', 'download_cursor', '--{ml_ignore}' )
~
call ml_add_table_script( 'ml_ra_agent_12', 'ml_ra_agent_status', 'download_delete_cursor', '--{ml_ignore}' )
~

call ml_add_connection_script( 'ml_ra_agent_12', 'authenticate_file_upload', 
    '{ call ml_ra_ss_agent_auth_file_xfer( ''U'', {ml s.file_authentication_code}, {ml s.username}, {ml s.remote_key}, {ml s.file_size}, {ml s.filename}, {ml s.subdir} ) }' )
~
call ml_add_connection_script( 'ml_ra_agent_12', 'authenticate_file_transfer', 
    '{ call ml_ra_ss_agent_auth_file_xfer( ''D'', {ml s.file_authentication_code}, {ml s.username}, {ml s.remote_key}, 0, {ml s.filename}, {ml s.subdir} ) }' )
~

call ml_add_property( 'SIRT', 'RTNotifier(RTNotifier1)', 'request_cursor', 'select agent_poll_key,task_instance_id,last_modified from ml_ra_notify order by agent_poll_key' )
~

-- RT Notifier doesn't begin polling until an agent is created
call ml_add_property( 'SIRT', 'RTNotifier(RTNotifier1)', 'poll_every', '2147483647' )
~

-- Set to 'no' to disable auto setting 'poll_every', then manually set 'poll_every'
call ml_add_property( 'SIRT', 'RTNotifier(RTNotifier1)', 'autoset_poll_every', 'yes' )
~

call ml_add_property( 'SIRT', 'RTNotifier(RTNotifier1)', 'enable', 'yes' )
~

-- Check for updates to started notifiers every minute
call ml_add_property( 'SIRT', 'Global', 'update_poll_every', '60' )
~

create procedure ml_ra_ss_download_task2(
    in p_taskdb_remote_id	varchar( 128 ) )
modifies SQL data
called on NULL input
language SQL
commit on return no
dynamic result sets 1
begin atomic
    declare crsr cursor with return to client for
	select task_instance_id, task_name, ml_ra_task.schema_name,
	    max_number_of_attempts, delay_between_attempts,
	    max_running_time, ml_ra_task.flags,
	    case dt.state 
		when 'P' then 'A'
		when 'CP' then 'C'
	    end,
	    cond, remote_event, random_delay_interval
	from ml_database task_db
	    join ml_ra_agent on ml_ra_agent.taskdb_rid = task_db.rid
	    join ml_ra_deployed_task dt on dt.aid = ml_ra_agent.aid
	    join ml_ra_task on dt.task_id = ml_ra_task.task_id
	where task_db.remote_id = p_taskdb_remote_id
	    and ( dt.state = 'CP' or dt.state = 'P' );
    open crsr;
end
~

/* Updated Script for 12.0.1 */
call ml_share_all_scripts( 'ml_ra_agent_12_1', 'ml_ra_agent_12' )
~
call ml_add_table_script( 'ml_ra_agent_12_1', 'ml_ra_agent_task', 'download_cursor', 
   'call ml_ra_ss_download_task2( {ml s.remote_id} )' )
~

commit
~
quit
~
